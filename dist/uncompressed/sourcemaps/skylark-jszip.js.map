{"version":3,"sources":["skylark-jszip.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-jszip.js","sourcesContent":["define('skylark-langx-binary/Buffer',[\r\n  \"./memory\"\r\n],function(Memory){\r\n  return Memory;\r\n});\ndefine('skylark-jszip/support',[\n    \"skylark-langx-binary/Buffer\",\n], function (Buffer) {\n    'use strict';\n    var support = {};\n\n    support.base64 = true;\n    support.array = true;\n    support.string = true;\n    support.arraybuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';\n    support.nodebuffer = support.buffer = true;///typeof Buffer !== 'undefined';\n    support.uint8array = typeof Uint8Array !== 'undefined';\n    if (typeof ArrayBuffer === 'undefined') {\n        support.blob = false;\n    } else {\n        var buffer = new ArrayBuffer(0);\n        try {\n            support.blob = new Blob([buffer], { type: 'application/zip' }).size === 0;\n        } catch (e) {\n            try {\n                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n                var builder = new Builder();\n                builder.append(buffer);\n                support.blob = builder.getBlob('application/zip').size === 0;\n            } catch (e) {\n                support.blob = false;\n            }\n        }\n    }\n\n    support.getTypeOf = function (input) {\n        if (typeof input === 'string') {\n            return 'string';\n        }\n        if (Object.prototype.toString.call(input) === '[object Array]') {\n            return 'array';\n        }\n        if (support.nodebuffer && Buffer.isBuffer(input)) {\n            return 'nodebuffer';\n        }\n        if (support.uint8array && input instanceof Uint8Array) {\n            return 'uint8array';\n        }\n        if (support.arraybuffer && input instanceof ArrayBuffer) {\n            return 'arraybuffer';\n        }\n    };\n\n    return support;\n});\ndefine('skylark-jszip/base64',[\n    './support'\n], function (support) {\n    'use strict';\n\n    var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    function encode(input) {\n        var output = [];\n        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n        var i = 0, len = input.length, remainingBytes = len;\n        var isArray = support.getTypeOf(input) !== 'string';\n        while (i < input.length) {\n            remainingBytes = len - i;\n            if (!isArray) {\n                chr1 = input.charCodeAt(i++);\n                chr2 = i < len ? input.charCodeAt(i++) : 0;\n                chr3 = i < len ? input.charCodeAt(i++) : 0;\n            } else {\n                chr1 = input[i++];\n                chr2 = i < len ? input[i++] : 0;\n                chr3 = i < len ? input[i++] : 0;\n            }\n            enc1 = chr1 >> 2;\n            enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n            enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;\n            enc4 = remainingBytes > 2 ? chr3 & 63 : 64;\n            output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n        }\n        return output.join('');\n    };\n    function decode(input) {\n        var chr1, chr2, chr3;\n        var enc1, enc2, enc3, enc4;\n        var i = 0, resultIndex = 0;\n        var dataUrlPrefix = 'data:';\n        if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n            throw new Error('Invalid base64 input, it looks like a data url.');\n        }\n        input = input.replace(/[^A-Za-z0-9+/=]/g, '');\n        var totalLength = input.length * 3 / 4;\n        if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (totalLength % 1 !== 0) {\n            throw new Error('Invalid base64 input, bad content length.');\n        }\n        var output;\n        if (support.uint8array) {\n            output = new Uint8Array(totalLength | 0);\n        } else {\n            output = new Array(totalLength | 0);\n        }\n        while (i < input.length) {\n            enc1 = _keyStr.indexOf(input.charAt(i++));\n            enc2 = _keyStr.indexOf(input.charAt(i++));\n            enc3 = _keyStr.indexOf(input.charAt(i++));\n            enc4 = _keyStr.indexOf(input.charAt(i++));\n            chr1 = enc1 << 2 | enc2 >> 4;\n            chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n            chr3 = (enc3 & 3) << 6 | enc4;\n            output[resultIndex++] = chr1;\n            if (enc3 !== 64) {\n                output[resultIndex++] = chr2;\n            }\n            if (enc4 !== 64) {\n                output[resultIndex++] = chr3;\n            }\n        }\n        return output;\n    };\n\n    return {\n        encode,\n        decode\n    }\n});\ndefine('skylark-jszip/external',[],function () {\n    'use strict';\n\n    return  { Promise};\n});\ndefine('skylark-jszip/utils',[\n    'skylark-langx-binary/buffer',\n    'skylark-langx-binary/transform',\n    'skylark-langx-binary/arraylike-to-string',\n    \"skylark-langx-constructs\",\n    './support',\n    './base64',\n    './external',\n], function (Buffer,transform,arrayLikeToString,constructs,support, base64, external) {\n    'use strict';\n    var utils = {};\n\n\n    utils.newBlob = function (part, type) {\n        utils.checkSupport('blob');\n        try {\n            return new Blob([part], { type: type });\n        } catch (e) {\n            try {\n                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n                var builder = new Builder();\n                builder.append(part);\n                return builder.getBlob(type);\n            } catch (e) {\n                throw new Error(\"Bug : can't construct the Blob.\");\n            }\n        }\n    };\n\n    utils.applyFromCharCode = arrayLikeToString;\n\n    utils.transformTo = function (outputType, input) {\n        /*\n        if (!input) {\n            input = '';\n        }\n        if (!outputType) {\n            return input;\n        }\n        utils.checkSupport(outputType);\n        var inputType = utils.getTypeOf(input);\n        var result = transform[inputType][outputType](input);\n        return result;\n        */\n        if (outputType==\"nodebuffer\") {\n            outputType = \"memory\";\n        }\n        return transform(outputType,input);\n    };\n    utils.resolve = function (path) {\n        var parts = path.split('/');\n        var result = [];\n        for (var index = 0; index < parts.length; index++) {\n            var part = parts[index];\n            if (part === '.' || part === '' && index !== 0 && index !== parts.length - 1) {\n                continue;\n            } else if (part === '..') {\n                result.pop();\n            } else {\n                result.push(part);\n            }\n        }\n        return result.join('/');\n    };\n    /*\n    utils.getTypeOf = function (input) {\n        if (typeof input === 'string') {\n            return 'string';\n        }\n        if (Object.prototype.toString.call(input) === '[object Array]') {\n            return 'array';\n        }\n        if (support.nodebuffer && Buffer.isBuffer(input)) {\n            return 'nodebuffer';\n        }\n        if (support.uint8array && input instanceof Uint8Array) {\n            return 'uint8array';\n        }\n        if (support.arraybuffer && input instanceof ArrayBuffer) {\n            return 'arraybuffer';\n        }\n    };\n    */\n    utils.getTypeOf = support.getTypeOf;\n    \n    utils.checkSupport = function (type) {\n        var supported = support[type.toLowerCase()];\n        if (!supported) {\n            throw new Error(type + ' is not supported by this platform');\n        }\n    };\n    utils.MAX_VALUE_16BITS = 65535;\n    utils.MAX_VALUE_32BITS = -1;\n    utils.pretty = function (str) {\n        var res = '', code, i;\n        for (i = 0; i < (str || '').length; i++) {\n            code = str.charCodeAt(i);\n            res += '\\\\x' + (code < 16 ? '0' : '') + code.toString(16).toUpperCase();\n        }\n        return res;\n    };\n    utils.delay = function (callback, args, self) {\n        setTimeout(function () {\n            callback.apply(self || null, args || []);\n        });\n    };\n    utils.inherits = function (ctor, superCtor) {\n        var Obj = function () {\n        };\n        Obj.prototype = superCtor.prototype;\n        ctor.prototype = new Obj();\n    };\n    utils.extend = function () {\n        var result = {}, i, attr;\n        for (i = 0; i < arguments.length; i++) {\n            for (attr in arguments[i]) {\n                if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === 'undefined') {\n                    result[attr] = arguments[i][attr];\n                }\n            }\n        }\n        return result;\n    };\n    utils.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n        var promise = external.Promise.resolve(inputData).then(function (data) {\n            var isBlob = support.blob && (data instanceof Blob || [\n                '[object File]',\n                '[object Blob]'\n            ].indexOf(Object.prototype.toString.call(data)) !== -1);\n            if (isBlob && typeof FileReader !== 'undefined') {\n                return new external.Promise(function (resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function (e) {\n                        resolve(e.target.result);\n                    };\n                    reader.onerror = function (e) {\n                        reject(e.target.error);\n                    };\n                    reader.readAsArrayBuffer(data);\n                });\n            } else {\n                return data;\n            }\n        });\n        return promise.then(function (data) {\n            var dataType = utils.getTypeOf(data);\n            if (!dataType) {\n                return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + 'in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?'));\n            }\n            if (dataType === 'arraybuffer') {\n                data = utils.transformTo('uint8array', data);\n            } else if (dataType === 'string') {\n                if (isBase64) {\n                    data = base64.decode(data);\n                } else if (isBinary) {\n                    if (isOptimizedBinaryString !== true) {\n                        data = string2binary(data);\n                    }\n                }\n            }\n            return data;\n        });\n    };\n\n    return utils;\n});\ndefine('skylark-jszip/stream/GenericWorker',[], function () {\n    'use strict';\n\n    function GenericWorker(name) {\n        this.name = name || 'default';\n        this.streamInfo = {};\n        this.generatedError = null;\n        this.extraStreamInfo = {};\n        this.isPaused = true;\n        this.isFinished = false;\n        this.isLocked = false;\n        this._listeners = {\n            'data': [],\n            'end': [],\n            'error': []\n        };\n        this.previous = null;\n    }\n    GenericWorker.prototype = {\n        push: function (chunk) {\n            this.emit('data', chunk);\n        },\n        end: function () {\n            if (this.isFinished) {\n                return false;\n            }\n            this.flush();\n            try {\n                this.emit('end');\n                this.cleanUp();\n                this.isFinished = true;\n            } catch (e) {\n                this.emit('error', e);\n            }\n            return true;\n        },\n        error: function (e) {\n            if (this.isFinished) {\n                return false;\n            }\n            if (this.isPaused) {\n                this.generatedError = e;\n            } else {\n                this.isFinished = true;\n                this.emit('error', e);\n                if (this.previous) {\n                    this.previous.error(e);\n                }\n                this.cleanUp();\n            }\n            return true;\n        },\n        on: function (name, listener) {\n            this._listeners[name].push(listener);\n            return this;\n        },\n        cleanUp: function () {\n            this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n            this._listeners = [];\n        },\n        emit: function (name, arg) {\n            if (this._listeners[name]) {\n                for (var i = 0; i < this._listeners[name].length; i++) {\n                    this._listeners[name][i].call(this, arg);\n                }\n            }\n        },\n        pipe: function (next) {\n            return next.registerPrevious(this);\n        },\n        registerPrevious: function (previous) {\n            if (this.isLocked) {\n                throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            }\n            this.streamInfo = previous.streamInfo;\n            this.mergeStreamInfo();\n            this.previous = previous;\n            var self = this;\n            previous.on('data', function (chunk) {\n                self.processChunk(chunk);\n            });\n            previous.on('end', function () {\n                self.end();\n            });\n            previous.on('error', function (e) {\n                self.error(e);\n            });\n            return this;\n        },\n        pause: function () {\n            if (this.isPaused || this.isFinished) {\n                return false;\n            }\n            this.isPaused = true;\n            if (this.previous) {\n                this.previous.pause();\n            }\n            return true;\n        },\n        resume: function () {\n            if (!this.isPaused || this.isFinished) {\n                return false;\n            }\n            this.isPaused = false;\n            var withError = false;\n            if (this.generatedError) {\n                this.error(this.generatedError);\n                withError = true;\n            }\n            if (this.previous) {\n                this.previous.resume();\n            }\n            return !withError;\n        },\n        flush: function () {\n        },\n        processChunk: function (chunk) {\n            this.push(chunk);\n        },\n        withStreamInfo: function (key, value) {\n            this.extraStreamInfo[key] = value;\n            this.mergeStreamInfo();\n            return this;\n        },\n        mergeStreamInfo: function () {\n            for (var key in this.extraStreamInfo) {\n                if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {\n                    continue;\n                }\n                this.streamInfo[key] = this.extraStreamInfo[key];\n            }\n        },\n        lock: function () {\n            if (this.isLocked) {\n                throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            }\n            this.isLocked = true;\n            if (this.previous) {\n                this.previous.lock();\n            }\n        },\n        toString: function () {\n            var me = 'Worker ' + this.name;\n            if (this.previous) {\n                return this.previous + ' -> ' + me;\n            } else {\n                return me;\n            }\n        }\n    };\n\n    return GenericWorker;\n\n});\ndefine('skylark-jszip/utf8',[\n    'skylark-langx-binary/buffer',\n    './utils',\n    './support',\n    './stream/GenericWorker'\n], function (Buffer,utils, support,  GenericWorker) {\n    'use strict';\n    var utf8 = {};\n\n    var _utf8len = new Array(256);\n    for (var i = 0; i < 256; i++) {\n        _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n    }\n    _utf8len[254] = _utf8len[254] = 1;\n    var string2buf = function (str) {\n        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n        for (m_pos = 0; m_pos < str_len; m_pos++) {\n            c = str.charCodeAt(m_pos);\n            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n                c2 = str.charCodeAt(m_pos + 1);\n                if ((c2 & 64512) === 56320) {\n                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n                    m_pos++;\n                }\n            }\n            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;\n        }\n        if (support.uint8array) {\n            buf = new Uint8Array(buf_len);\n        } else {\n            buf = new Array(buf_len);\n        }\n        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n            c = str.charCodeAt(m_pos);\n            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n                c2 = str.charCodeAt(m_pos + 1);\n                if ((c2 & 64512) === 56320) {\n                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n                    m_pos++;\n                }\n            }\n            if (c < 128) {\n                buf[i++] = c;\n            } else if (c < 2048) {\n                buf[i++] = 192 | c >>> 6;\n                buf[i++] = 128 | c & 63;\n            } else if (c < 65536) {\n                buf[i++] = 224 | c >>> 12;\n                buf[i++] = 128 | c >>> 6 & 63;\n                buf[i++] = 128 | c & 63;\n            } else {\n                buf[i++] = 240 | c >>> 18;\n                buf[i++] = 128 | c >>> 12 & 63;\n                buf[i++] = 128 | c >>> 6 & 63;\n                buf[i++] = 128 | c & 63;\n            }\n        }\n        return buf;\n    };\n    var utf8border = function (buf, max) {\n        var pos;\n        max = max || buf.length;\n        if (max > buf.length) {\n            max = buf.length;\n        }\n        pos = max - 1;\n        while (pos >= 0 && (buf[pos] & 192) === 128) {\n            pos--;\n        }\n        if (pos < 0) {\n            return max;\n        }\n        if (pos === 0) {\n            return max;\n        }\n        return pos + _utf8len[buf[pos]] > max ? pos : max;\n    };\n    var buf2string = function (buf) {\n        var i, out, c, c_len;\n        var len = buf.length;\n        var utf16buf = new Array(len * 2);\n        for (out = 0, i = 0; i < len;) {\n            c = buf[i++];\n            if (c < 128) {\n                utf16buf[out++] = c;\n                continue;\n            }\n            c_len = _utf8len[c];\n            if (c_len > 4) {\n                utf16buf[out++] = 65533;\n                i += c_len - 1;\n                continue;\n            }\n            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n            while (c_len > 1 && i < len) {\n                c = c << 6 | buf[i++] & 63;\n                c_len--;\n            }\n            if (c_len > 1) {\n                utf16buf[out++] = 65533;\n                continue;\n            }\n            if (c < 65536) {\n                utf16buf[out++] = c;\n            } else {\n                c -= 65536;\n                utf16buf[out++] = 55296 | c >> 10 & 1023;\n                utf16buf[out++] = 56320 | c & 1023;\n            }\n        }\n        if (utf16buf.length !== out) {\n            if (utf16buf.subarray) {\n                utf16buf = utf16buf.subarray(0, out);\n            } else {\n                utf16buf.length = out;\n            }\n        }\n        return utils.applyFromCharCode(utf16buf);\n    };\n    utf8.utf8encode = function utf8encode(str) {\n        if (support.nodebuffer) {\n            ///return nodejsUtils.newBufferFrom(str, 'utf-8');\n            return Buffer.from(str,'utf-8');\n        }\n        return string2buf(str);\n    };\n    utf8.utf8decode = function utf8decode(buf) {\n        if (support.nodebuffer) {\n            return utils.transformTo('nodebuffer', buf).toString('utf-8');\n        }\n        buf = utils.transformTo(support.uint8array ? 'uint8array' : 'array', buf);\n        return buf2string(buf);\n    };\n    function Utf8DecodeWorker() {\n        GenericWorker.call(this, 'utf-8 decode');\n        this.leftOver = null;\n    }\n    utils.inherits(Utf8DecodeWorker, GenericWorker);\n    Utf8DecodeWorker.prototype.processChunk = function (chunk) {\n        var data = utils.transformTo(support.uint8array ? 'uint8array' : 'array', chunk.data);\n        if (this.leftOver && this.leftOver.length) {\n            if (support.uint8array) {\n                var previousData = data;\n                data = new Uint8Array(previousData.length + this.leftOver.length);\n                data.set(this.leftOver, 0);\n                data.set(previousData, this.leftOver.length);\n            } else {\n                data = this.leftOver.concat(data);\n            }\n            this.leftOver = null;\n        }\n        var nextBoundary = utf8border(data);\n        var usableData = data;\n        if (nextBoundary !== data.length) {\n            if (support.uint8array) {\n                usableData = data.subarray(0, nextBoundary);\n                this.leftOver = data.subarray(nextBoundary, data.length);\n            } else {\n                usableData = data.slice(0, nextBoundary);\n                this.leftOver = data.slice(nextBoundary, data.length);\n            }\n        }\n        this.push({\n            data: utf8.utf8decode(usableData),\n            meta: chunk.meta\n        });\n    };\n    Utf8DecodeWorker.prototype.flush = function () {\n        if (this.leftOver && this.leftOver.length) {\n            this.push({\n                data: utf8.utf8decode(this.leftOver),\n                meta: {}\n            });\n            this.leftOver = null;\n        }\n    };\n    utf8.Utf8DecodeWorker = Utf8DecodeWorker;\n    function Utf8EncodeWorker() {\n        GenericWorker.call(this, 'utf-8 encode');\n    }\n    utils.inherits(Utf8EncodeWorker, GenericWorker);\n    Utf8EncodeWorker.prototype.processChunk = function (chunk) {\n        this.push({\n            data: utf8.utf8encode(chunk.data),\n            meta: chunk.meta\n        });\n    };\n    utf8.Utf8EncodeWorker = Utf8EncodeWorker;\n\n    return utf8;\n});\ndefine('skylark-jszip/stream/ConvertWorker',[\n    './GenericWorker',\n    '../utils'\n], function (GenericWorker, utils) {\n    'use strict';\n\n    function ConvertWorker(destType) {\n        GenericWorker.call(this, 'ConvertWorker to ' + destType);\n        this.destType = destType;\n    }\n    utils.inherits(ConvertWorker, GenericWorker);\n    ConvertWorker.prototype.processChunk = function (chunk) {\n        this.push({\n            data: utils.transformTo(this.destType, chunk.data),\n            meta: chunk.meta\n        });\n    };\n\n    return ConvertWorker;\n\n});\ndefine('skylark-jszip/stream/StreamHelper',[\n    '../utils',\n    './ConvertWorker',\n    './GenericWorker',\n    '../base64',\n    '../support',\n    '../external'\n], function (utils, ConvertWorker, GenericWorker, base64, support, external) {\n    'use strict';\n\n    ///if (support.nodestream) {\n    ///    try {\n    ///        NodejsStreamOutputAdapter = __module__6;\n    ///    } catch (e) {\n    ///    }\n    ///}\n    function transformZipOutput(type, content, mimeType) {\n        switch (type) {\n        case 'blob':\n            return utils.newBlob(utils.transformTo('arraybuffer', content), mimeType);\n        case 'base64':\n            return base64.encode(content);\n        default:\n            return utils.transformTo(type, content);\n        }\n    }\n    function concat(type, dataArray) {\n        var i, index = 0, res = null, totalLength = 0;\n        for (i = 0; i < dataArray.length; i++) {\n            totalLength += dataArray[i].length;\n        }\n        switch (type) {\n        case 'string':\n            return dataArray.join('');\n        case 'array':\n            return Array.prototype.concat.apply([], dataArray);\n        case 'uint8array':\n            res = new Uint8Array(totalLength);\n            for (i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case 'nodebuffer':\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\" + type + \"'\");\n        }\n    }\n    function accumulate(helper, updateCallback) {\n        return new external.Promise(function (resolve, reject) {\n            var dataArray = [];\n            var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;\n            helper.on('data', function (data, meta) {\n                dataArray.push(data);\n                if (updateCallback) {\n                    updateCallback(meta);\n                }\n            }).on('error', function (err) {\n                dataArray = [];\n                reject(err);\n            }).on('end', function () {\n                try {\n                    var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n                dataArray = [];\n            }).resume();\n        });\n    }\n    function StreamHelper(worker, outputType, mimeType) {\n        var internalType = outputType;\n        switch (outputType) {\n        case 'blob':\n        case 'arraybuffer':\n            internalType = 'uint8array';\n            break;\n        case 'base64':\n            internalType = 'string';\n            break;\n        }\n        try {\n            this._internalType = internalType;\n            this._outputType = outputType;\n            this._mimeType = mimeType;\n            utils.checkSupport(internalType);\n            this._worker = worker.pipe(new ConvertWorker(internalType));\n            worker.lock();\n        } catch (e) {\n            this._worker = new GenericWorker('error');\n            this._worker.error(e);\n        }\n    }\n    StreamHelper.prototype = {\n        accumulate: function (updateCb) {\n            return accumulate(this, updateCb);\n        },\n        on: function (evt, fn) {\n            var self = this;\n            if (evt === 'data') {\n                this._worker.on(evt, function (chunk) {\n                    fn.call(self, chunk.data, chunk.meta);\n                });\n            } else {\n                this._worker.on(evt, function () {\n                    utils.delay(fn, arguments, self);\n                });\n            }\n            return this;\n        },\n        resume: function () {\n            utils.delay(this._worker.resume, [], this._worker);\n            return this;\n        },\n        pause: function () {\n            this._worker.pause();\n            return this;\n        },\n        toNodejsStream: function (updateCb) {\n            utils.checkSupport('nodestream');\n            if (this._outputType !== 'nodebuffer') {\n                throw new Error(this._outputType + ' is not supported by this method');\n            }\n            return new NodejsStreamOutputAdapter(this, { objectMode: this._outputType !== 'nodebuffer' }, updateCb);\n        }\n    };\n   \n    return StreamHelper;\n});\ndefine('skylark-jszip/defaults',[], function () {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    exports.base64 = false;\n    exports.binary = false;\n    exports.dir = false;\n    exports.createFolders = true;\n    exports.date = null;\n    exports.compression = null;\n    exports.compressionOptions = null;\n    exports.comment = null;\n    exports.unixPermissions = null;\n    exports.dosPermissions = null;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-jszip/stream/DataWorker',[\n    '../utils',\n    './GenericWorker'\n], function (utils, GenericWorker) {\n    'use strict';\n\n    var DEFAULT_BLOCK_SIZE = 16 * 1024;\n    function DataWorker(dataP) {\n        GenericWorker.call(this, 'DataWorker');\n        var self = this;\n        this.dataIsReady = false;\n        this.index = 0;\n        this.max = 0;\n        this.data = null;\n        this.type = '';\n        this._tickScheduled = false;\n        dataP.then(function (data) {\n            self.dataIsReady = true;\n            self.data = data;\n            self.max = data && data.length || 0;\n            self.type = utils.getTypeOf(data);\n            if (!self.isPaused) {\n                self._tickAndRepeat();\n            }\n        }, function (e) {\n            self.error(e);\n        });\n    }\n    utils.inherits(DataWorker, GenericWorker);\n    DataWorker.prototype.cleanUp = function () {\n        GenericWorker.prototype.cleanUp.call(this);\n        this.data = null;\n    };\n    DataWorker.prototype.resume = function () {\n        if (!GenericWorker.prototype.resume.call(this)) {\n            return false;\n        }\n        if (!this._tickScheduled && this.dataIsReady) {\n            this._tickScheduled = true;\n            utils.delay(this._tickAndRepeat, [], this);\n        }\n        return true;\n    };\n    DataWorker.prototype._tickAndRepeat = function () {\n        this._tickScheduled = false;\n        if (this.isPaused || this.isFinished) {\n            return;\n        }\n        this._tick();\n        if (!this.isFinished) {\n            utils.delay(this._tickAndRepeat, [], this);\n            this._tickScheduled = true;\n        }\n    };\n    DataWorker.prototype._tick = function () {\n        if (this.isPaused || this.isFinished) {\n            return false;\n        }\n        var size = DEFAULT_BLOCK_SIZE;\n        var data = null, nextIndex = Math.min(this.max, this.index + size);\n        if (this.index >= this.max) {\n            return this.end();\n        } else {\n            switch (this.type) {\n            case 'string':\n                data = this.data.substring(this.index, nextIndex);\n                break;\n            case 'uint8array':\n                data = this.data.subarray(this.index, nextIndex);\n                break;\n            case 'array':\n            case 'nodebuffer':\n                data = this.data.slice(this.index, nextIndex);\n                break;\n            }\n            this.index = nextIndex;\n            return this.push({\n                data: data,\n                meta: { percent: this.max ? this.index / this.max * 100 : 0 }\n            });\n        }\n    };\n    \n    return DataWorker;\n});\ndefine('skylark-jszip/crc32',['./utils'], function (utils) {\n    'use strict';\n\n    function makeTable() {\n        var c, table = [];\n        for (var n = 0; n < 256; n++) {\n            c = n;\n            for (var k = 0; k < 8; k++) {\n                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n            }\n            table[n] = c;\n        }\n        return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n        var t = crcTable, end = pos + len;\n        crc = crc ^ -1;\n        for (var i = pos; i < end; i++) {\n            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n        }\n        return crc ^ -1;\n    }\n    function crc32str(crc, str, len, pos) {\n        var t = crcTable, end = pos + len;\n        crc = crc ^ -1;\n        for (var i = pos; i < end; i++) {\n            crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];\n        }\n        return crc ^ -1;\n    }\n    function crc32wrapper(input, crc) {\n        if (typeof input === 'undefined' || !input.length) {\n            return 0;\n        }\n        var isArray = utils.getTypeOf(input) !== 'string';\n        if (isArray) {\n            return crc32(crc | 0, input, input.length, 0);\n        } else {\n            return crc32str(crc | 0, input, input.length, 0);\n        }\n    }\n\n    return crc32wrapper;\n});\ndefine('skylark-jszip/stream/Crc32Probe',[\n    './GenericWorker',\n    '../crc32',\n    '../utils'\n], function (GenericWorker, crc32, utils) {\n    'use strict';\n\n    function Crc32Probe() {\n        GenericWorker.call(this, 'Crc32Probe');\n        this.withStreamInfo('crc32', 0);\n    }\n    utils.inherits(Crc32Probe, GenericWorker);\n    Crc32Probe.prototype.processChunk = function (chunk) {\n        this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n        this.push(chunk);\n    };\n    \n    return Crc32Probe;\n\n});\ndefine('skylark-jszip/stream/DataLengthProbe',[\n    '../utils',\n    './GenericWorker'\n], function (utils, GenericWorker) {\n    'use strict';\n\n    function DataLengthProbe(propName) {\n        GenericWorker.call(this, 'DataLengthProbe for ' + propName);\n        this.propName = propName;\n        this.withStreamInfo(propName, 0);\n    }\n    utils.inherits(DataLengthProbe, GenericWorker);\n    DataLengthProbe.prototype.processChunk = function (chunk) {\n        if (chunk) {\n            var length = this.streamInfo[this.propName] || 0;\n            this.streamInfo[this.propName] = length + chunk.data.length;\n        }\n        GenericWorker.prototype.processChunk.call(this, chunk);\n    };\n    return DataLengthProbe;\n\n});\ndefine('skylark-jszip/compressedObject',[\n    './external',\n    './stream/DataWorker',\n    './stream/Crc32Probe',\n    './stream/DataLengthProbe'\n], function (external, DataWorker, Crc32Probe, DataLengthProbe) {\n    'use strict';\n\n    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n        this.compressedSize = compressedSize;\n        this.uncompressedSize = uncompressedSize;\n        this.crc32 = crc32;\n        this.compression = compression;\n        this.compressedContent = data;\n    }\n    CompressedObject.prototype = {\n        getContentWorker: function () {\n            var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe('data_length'));\n            var that = this;\n            worker.on('end', function () {\n                if (this.streamInfo['data_length'] !== that.uncompressedSize) {\n                    throw new Error('Bug : uncompressed data size mismatch');\n                }\n            });\n            return worker;\n        },\n        getCompressedWorker: function () {\n            return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo('compressedSize', this.compressedSize).withStreamInfo('uncompressedSize', this.uncompressedSize).withStreamInfo('crc32', this.crc32).withStreamInfo('compression', this.compression);\n        }\n    };\n    CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n        return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe('uncompressedSize')).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe('compressedSize')).withStreamInfo('compression', compression);\n    };\n    \n    return CompressedObject;\n\n});\ndefine('skylark-jszip/zipObject',[\n    './stream/StreamHelper',\n    './stream/DataWorker',\n    './utf8',\n    './compressedObject',\n    './stream/GenericWorker'\n], function (StreamHelper, DataWorker, utf8, CompressedObject, GenericWorker) {\n    'use strict';\n\n    var ZipObject = function (name, data, options) {\n        this.name = name;\n        this.dir = options.dir;\n        this.date = options.date;\n        this.comment = options.comment;\n        this.unixPermissions = options.unixPermissions;\n        this.dosPermissions = options.dosPermissions;\n        this._data = data;\n        this._dataBinary = options.binary;\n        this.options = {\n            compression: options.compression,\n            compressionOptions: options.compressionOptions\n        };\n    };\n    ZipObject.prototype = {\n        internalStream: function (type) {\n            var result = null, outputType = 'string';\n            try {\n                if (!type) {\n                    throw new Error('No output type specified.');\n                }\n                outputType = type.toLowerCase();\n                var askUnicodeString = outputType === 'string' || outputType === 'text';\n                if (outputType === 'binarystring' || outputType === 'text') {\n                    outputType = 'string';\n                }\n                result = this._decompressWorker();\n                var isUnicodeString = !this._dataBinary;\n                if (isUnicodeString && !askUnicodeString) {\n                    result = result.pipe(new utf8.Utf8EncodeWorker());\n                }\n                if (!isUnicodeString && askUnicodeString) {\n                    result = result.pipe(new utf8.Utf8DecodeWorker());\n                }\n            } catch (e) {\n                result = new GenericWorker('error');\n                result.error(e);\n            }\n            return new StreamHelper(result, outputType, '');\n        },\n        async: function (type, onUpdate) {\n            return this.internalStream(type).accumulate(onUpdate);\n        },\n        nodeStream: function (type, onUpdate) {\n            return this.internalStream(type || 'nodebuffer').toNodejsStream(onUpdate);\n        },\n        _compressWorker: function (compression, compressionOptions) {\n            if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n                return this._data.getCompressedWorker();\n            } else {\n                var result = this._decompressWorker();\n                if (!this._dataBinary) {\n                    result = result.pipe(new utf8.Utf8EncodeWorker());\n                }\n                return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n            }\n        },\n        _decompressWorker: function () {\n            if (this._data instanceof CompressedObject) {\n                return this._data.getContentWorker();\n            } else if (this._data instanceof GenericWorker) {\n                return this._data;\n            } else {\n                return new DataWorker(this._data);\n            }\n        }\n    };\n    var removedMethods = [\n        'asText',\n        'asBinary',\n        'asNodeBuffer',\n        'asUint8Array',\n        'asArrayBuffer'\n    ];\n    var removedFn = function () {\n        throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.');\n    };\n    for (var i = 0; i < removedMethods.length; i++) {\n        ZipObject.prototype[removedMethods[i]] = removedFn;\n    }\n    return ZipObject;\n\n});\ndefine('skylark-jszip/flate',[\n    'skylark-pako',\n    './utils',\n    './stream/GenericWorker'\n], function (pako, utils, GenericWorker) {\n    'use strict';\n\n    var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';\n\n    var ARRAY_TYPE = USE_TYPEDARRAY ? 'uint8array' : 'array';\n\n    var flate = {};\n\n    flate.magic = '\\b\\0';\n\n    function FlateWorker(action, options) {\n        GenericWorker.call(this, 'FlateWorker/' + action);\n        this._pako = null;\n        this._pakoAction = action;\n        this._pakoOptions = options;\n        this.meta = {};\n    }\n\n    utils.inherits(FlateWorker, GenericWorker);\n\n    FlateWorker.prototype.processChunk = function (chunk) {\n        this.meta = chunk.meta;\n        if (this._pako === null) {\n            this._createPako();\n        }\n        this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n    };\n    FlateWorker.prototype.flush = function () {\n        GenericWorker.prototype.flush.call(this);\n        if (this._pako === null) {\n            this._createPako();\n        }\n        this._pako.push([], true);\n    };\n    FlateWorker.prototype.cleanUp = function () {\n        GenericWorker.prototype.cleanUp.call(this);\n        this._pako = null;\n    };\n    FlateWorker.prototype._createPako = function () {\n        this._pako = new pako[this._pakoAction]({\n            raw: true,\n            level: this._pakoOptions.level || -1\n        });\n        var self = this;\n        this._pako.onData = function (data) {\n            self.push({\n                data: data,\n                meta: self.meta\n            });\n        };\n    };\n\n    flate.compressWorker = function (compressionOptions) {\n        return new FlateWorker(\"Deflate\", compressionOptions);\n    };\n    flate.uncompressWorker = function () {\n        return new FlateWorker(\"Inflate\", {});\n    };\n\n    return flate;\n});\ndefine('skylark-jszip/compressions',[\n    './stream/GenericWorker',\n    './flate'\n], function (GenericWorker, DEFLATE) {\n    'use strict';\n\n    var STORE = {\n        magic: '\\0\\0',\n        compressWorker: function () {\n            return new GenericWorker('STORE compression');\n        },\n        uncompressWorker: function () {\n            return new GenericWorker('STORE decompression');\n        }\n    };\n\n    return {\n        STORE,\n        DEFLATE\n    }\n});\ndefine('skylark-jszip/signature',[], function () {\n    'use strict';\n\n    const LOCAL_FILE_HEADER = 'PK\\x03\\x04';\n    const CENTRAL_FILE_HEADER = 'PK\\x01\\x02';\n    const CENTRAL_DIRECTORY_END = 'PK\\x05\\x06';\n    const ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\\x06\\x07';\n    const ZIP64_CENTRAL_DIRECTORY_END = 'PK\\x06\\x06';\n    const DATA_DESCRIPTOR = 'PK\\x07\\b';\n\n    return {\n        LOCAL_FILE_HEADER,\n        CENTRAL_FILE_HEADER,\n        CENTRAL_DIRECTORY_END,\n        ZIP64_CENTRAL_DIRECTORY_LOCATOR,\n        ZIP64_CENTRAL_DIRECTORY_END,\n        DATA_DESCRIPTOR\n    };\n});\ndefine('skylark-jszip/generate/ZipFileWorker',[\n    '../utils',\n    '../stream/GenericWorker',\n    '../utf8',\n    '../crc32',\n    '../signature'\n], function (utils, GenericWorker, utf8, crc32, signature) {\n    'use strict';\n\n    var decToHex = function (dec, bytes) {\n        var hex = '', i;\n        for (i = 0; i < bytes; i++) {\n            hex += String.fromCharCode(dec & 255);\n            dec = dec >>> 8;\n        }\n        return hex;\n    };\n    var generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n        var result = unixPermissions;\n        if (!unixPermissions) {\n            result = isDir ? 16893 : 33204;\n        }\n        return (result & 65535) << 16;\n    };\n    var generateDosExternalFileAttr = function (dosPermissions) {\n        return (dosPermissions || 0) & 63;\n    };\n    var generateZipParts = function (streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n        var file = streamInfo['file'], compression = streamInfo['compression'], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo('string', encodeFileName(file.name)), utfEncodedFileName = utils.transformTo('string', utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo('string', encodeFileName(comment)), utfEncodedComment = utils.transformTo('string', utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = '', unicodePathExtraField = '', unicodeCommentExtraField = '', dir = file.dir, date = file.date;\n        var dataInfo = {\n            crc32: 0,\n            compressedSize: 0,\n            uncompressedSize: 0\n        };\n        if (!streamedContent || streamingEnded) {\n            dataInfo.crc32 = streamInfo['crc32'];\n            dataInfo.compressedSize = streamInfo['compressedSize'];\n            dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n        }\n        var bitflag = 0;\n        if (streamedContent) {\n            bitflag |= 8;\n        }\n        if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n            bitflag |= 2048;\n        }\n        var extFileAttr = 0;\n        var versionMadeBy = 0;\n        if (dir) {\n            extFileAttr |= 16;\n        }\n        if (platform === 'UNIX') {\n            versionMadeBy = 798;\n            extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n        } else {\n            versionMadeBy = 20;\n            extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n        }\n        dosTime = date.getUTCHours();\n        dosTime = dosTime << 6;\n        dosTime = dosTime | date.getUTCMinutes();\n        dosTime = dosTime << 5;\n        dosTime = dosTime | date.getUTCSeconds() / 2;\n        dosDate = date.getUTCFullYear() - 1980;\n        dosDate = dosDate << 4;\n        dosDate = dosDate | date.getUTCMonth() + 1;\n        dosDate = dosDate << 5;\n        dosDate = dosDate | date.getUTCDate();\n        if (useUTF8ForFileName) {\n            unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;\n            extraFields += 'up' + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;\n        }\n        if (useUTF8ForComment) {\n            unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;\n            extraFields += 'uc' + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;\n        }\n        var header = '';\n        header += '\\n\\0';\n        header += decToHex(bitflag, 2);\n        header += compression.magic;\n        header += decToHex(dosTime, 2);\n        header += decToHex(dosDate, 2);\n        header += decToHex(dataInfo.crc32, 4);\n        header += decToHex(dataInfo.compressedSize, 4);\n        header += decToHex(dataInfo.uncompressedSize, 4);\n        header += decToHex(encodedFileName.length, 2);\n        header += decToHex(extraFields.length, 2);\n        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n        var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + '\\0\\0' + '\\0\\0' + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;\n        return {\n            fileRecord: fileRecord,\n            dirRecord: dirRecord\n        };\n    };\n    var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n        var dirEnd = '';\n        var encodedComment = utils.transformTo('string', encodeFileName(comment));\n        dirEnd = signature.CENTRAL_DIRECTORY_END + '\\0\\0' + '\\0\\0' + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;\n        return dirEnd;\n    };\n    var generateDataDescriptors = function (streamInfo) {\n        var descriptor = '';\n        descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo['crc32'], 4) + decToHex(streamInfo['compressedSize'], 4) + decToHex(streamInfo['uncompressedSize'], 4);\n        return descriptor;\n    };\n    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n        GenericWorker.call(this, 'ZipFileWorker');\n        this.bytesWritten = 0;\n        this.zipComment = comment;\n        this.zipPlatform = platform;\n        this.encodeFileName = encodeFileName;\n        this.streamFiles = streamFiles;\n        this.accumulate = false;\n        this.contentBuffer = [];\n        this.dirRecords = [];\n        this.currentSourceOffset = 0;\n        this.entriesCount = 0;\n        this.currentFile = null;\n        this._sources = [];\n    }\n    utils.inherits(ZipFileWorker, GenericWorker);\n    ZipFileWorker.prototype.push = function (chunk) {\n        var currentFilePercent = chunk.meta.percent || 0;\n        var entriesCount = this.entriesCount;\n        var remainingFiles = this._sources.length;\n        if (this.accumulate) {\n            this.contentBuffer.push(chunk);\n        } else {\n            this.bytesWritten += chunk.data.length;\n            GenericWorker.prototype.push.call(this, {\n                data: chunk.data,\n                meta: {\n                    currentFile: this.currentFile,\n                    percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n                }\n            });\n        }\n    };\n    ZipFileWorker.prototype.openedSource = function (streamInfo) {\n        this.currentSourceOffset = this.bytesWritten;\n        this.currentFile = streamInfo['file'].name;\n        var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n        if (streamedContent) {\n            var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n            this.push({\n                data: record.fileRecord,\n                meta: { percent: 0 }\n            });\n        } else {\n            this.accumulate = true;\n        }\n    };\n    ZipFileWorker.prototype.closedSource = function (streamInfo) {\n        this.accumulate = false;\n        var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n        var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.dirRecords.push(record.dirRecord);\n        if (streamedContent) {\n            this.push({\n                data: generateDataDescriptors(streamInfo),\n                meta: { percent: 100 }\n            });\n        } else {\n            this.push({\n                data: record.fileRecord,\n                meta: { percent: 0 }\n            });\n            while (this.contentBuffer.length) {\n                this.push(this.contentBuffer.shift());\n            }\n        }\n        this.currentFile = null;\n    };\n    ZipFileWorker.prototype.flush = function () {\n        var localDirLength = this.bytesWritten;\n        for (var i = 0; i < this.dirRecords.length; i++) {\n            this.push({\n                data: this.dirRecords[i],\n                meta: { percent: 100 }\n            });\n        }\n        var centralDirLength = this.bytesWritten - localDirLength;\n        var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n        this.push({\n            data: dirEnd,\n            meta: { percent: 100 }\n        });\n    };\n    ZipFileWorker.prototype.prepareNextSource = function () {\n        this.previous = this._sources.shift();\n        this.openedSource(this.previous.streamInfo);\n        if (this.isPaused) {\n            this.previous.pause();\n        } else {\n            this.previous.resume();\n        }\n    };\n    ZipFileWorker.prototype.registerPrevious = function (previous) {\n        this._sources.push(previous);\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.closedSource(self.previous.streamInfo);\n            if (self._sources.length) {\n                self.prepareNextSource();\n            } else {\n                self.end();\n            }\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    };\n    ZipFileWorker.prototype.resume = function () {\n        if (!GenericWorker.prototype.resume.call(this)) {\n            return false;\n        }\n        if (!this.previous && this._sources.length) {\n            this.prepareNextSource();\n            return true;\n        }\n        if (!this.previous && !this._sources.length && !this.generatedError) {\n            this.end();\n            return true;\n        }\n    };\n    ZipFileWorker.prototype.error = function (e) {\n        var sources = this._sources;\n        if (!GenericWorker.prototype.error.call(this, e)) {\n            return false;\n        }\n        for (var i = 0; i < sources.length; i++) {\n            try {\n                sources[i].error(e);\n            } catch (e) {\n            }\n        }\n        return true;\n    };\n    ZipFileWorker.prototype.lock = function () {\n        GenericWorker.prototype.lock.call(this);\n        var sources = this._sources;\n        for (var i = 0; i < sources.length; i++) {\n            sources[i].lock();\n        }\n    };\n\n    return ZipFileWorker;\n\n});\ndefine('skylark-jszip/generate',[\r\n    './compressions',\r\n    './generate/ZipFileWorker'\r\n], function (compressions, ZipFileWorker) {\r\n    'use strict';\r\n\r\n    var getCompression = function (fileCompression, zipCompression) {\r\n        var compressionName = fileCompression || zipCompression;\r\n        var compression = compressions[compressionName];\r\n        if (!compression) {\r\n            throw new Error(compressionName + ' is not a valid compression method !');\r\n        }\r\n        return compression;\r\n    };\r\n    function generateWorker(zip, options, comment) {\r\n        var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\r\n        var entriesCount = 0;\r\n        try {\r\n            zip.forEach(function (relativePath, file) {\r\n                entriesCount++;\r\n                var compression = getCompression(file.options.compression, options.compression);\r\n                var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\r\n                var dir = file.dir, date = file.date;\r\n                file._compressWorker(compression, compressionOptions).withStreamInfo('file', {\r\n                    name: relativePath,\r\n                    dir: dir,\r\n                    date: date,\r\n                    comment: file.comment || '',\r\n                    unixPermissions: file.unixPermissions,\r\n                    dosPermissions: file.dosPermissions\r\n                }).pipe(zipFileWorker);\r\n            });\r\n            zipFileWorker.entriesCount = entriesCount;\r\n        } catch (e) {\r\n            zipFileWorker.error(e);\r\n        }\r\n        return zipFileWorker;\r\n    };\r\n\r\n    return generateWorker;\r\n\r\n});\ndefine('skylark-jszip/object',[\n    './utf8',\n    './utils',\n    './stream/GenericWorker',\n    './stream/StreamHelper',\n    './defaults',\n    './compressedObject',\n    './zipObject',\n    './generate'\n], function (utf8, utils, GenericWorker, StreamHelper, defaults, CompressedObject, ZipObject, generate) {\n    'use strict';\n\n    var fileAdd = function (name, data, originalOptions) {\n        var dataType = utils.getTypeOf(data), parent;\n        var o = utils.extend(originalOptions || {}, defaults);\n        o.date = o.date || new Date();\n        if (o.compression !== null) {\n            o.compression = o.compression.toUpperCase();\n        }\n        if (typeof o.unixPermissions === 'string') {\n            o.unixPermissions = parseInt(o.unixPermissions, 8);\n        }\n        if (o.unixPermissions && o.unixPermissions & 16384) {\n            o.dir = true;\n        }\n        if (o.dosPermissions && o.dosPermissions & 16) {\n            o.dir = true;\n        }\n        if (o.dir) {\n            name = forceTrailingSlash(name);\n        }\n        if (o.createFolders && (parent = parentFolder(name))) {\n            folderAdd.call(this, parent, true);\n        }\n        var isUnicodeString = dataType === 'string' && o.binary === false && o.base64 === false;\n        if (!originalOptions || typeof originalOptions.binary === 'undefined') {\n            o.binary = !isUnicodeString;\n        }\n        var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;\n        if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n            o.base64 = false;\n            o.binary = true;\n            data = '';\n            o.compression = 'STORE';\n            dataType = 'string';\n        }\n        var zipObjectContent = null;\n        if (data instanceof CompressedObject || data instanceof GenericWorker) {\n            zipObjectContent = data;\n        ///} else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        ///    zipObjectContent = new NodejsStreamInputAdapter(name, data);\n        } else {\n            zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n        }\n        var object = new ZipObject(name, zipObjectContent, o);\n        this.files[name] = object;\n    };\n    var parentFolder = function (path) {\n        if (path.slice(-1) === '/') {\n            path = path.substring(0, path.length - 1);\n        }\n        var lastSlash = path.lastIndexOf('/');\n        return lastSlash > 0 ? path.substring(0, lastSlash) : '';\n    };\n    var forceTrailingSlash = function (path) {\n        if (path.slice(-1) !== '/') {\n            path += '/';\n        }\n        return path;\n    };\n    var folderAdd = function (name, createFolders) {\n        createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;\n        name = forceTrailingSlash(name);\n        if (!this.files[name]) {\n            fileAdd.call(this, name, null, {\n                dir: true,\n                createFolders: createFolders\n            });\n        }\n        return this.files[name];\n    };\n    function isRegExp(object) {\n        return Object.prototype.toString.call(object) === '[object RegExp]';\n    }\n    var out = {\n        load: function () {\n            throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.');\n        },\n        forEach: function (cb) {\n            var filename, relativePath, file;\n            for (filename in this.files) {\n                file = this.files[filename];\n                relativePath = filename.slice(this.root.length, filename.length);\n                if (relativePath && filename.slice(0, this.root.length) === this.root) {\n                    cb(relativePath, file);\n                }\n            }\n        },\n        filter: function (search) {\n            var result = [];\n            this.forEach(function (relativePath, entry) {\n                if (search(relativePath, entry)) {\n                    result.push(entry);\n                }\n            });\n            return result;\n        },\n        file: function (name, data, o) {\n            if (arguments.length === 1) {\n                if (isRegExp(name)) {\n                    var regexp = name;\n                    return this.filter(function (relativePath, file) {\n                        return !file.dir && regexp.test(relativePath);\n                    });\n                } else {\n                    var obj = this.files[this.root + name];\n                    if (obj && !obj.dir) {\n                        return obj;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                name = this.root + name;\n                fileAdd.call(this, name, data, o);\n            }\n            return this;\n        },\n        folder: function (arg) {\n            if (!arg) {\n                return this;\n            }\n            if (isRegExp(arg)) {\n                return this.filter(function (relativePath, file) {\n                    return file.dir && arg.test(relativePath);\n                });\n            }\n            var name = this.root + arg;\n            var newFolder = folderAdd.call(this, name);\n            var ret = this.clone();\n            ret.root = newFolder.name;\n            return ret;\n        },\n        remove: function (name) {\n            name = this.root + name;\n            var file = this.files[name];\n            if (!file) {\n                if (name.slice(-1) !== '/') {\n                    name += '/';\n                }\n                file = this.files[name];\n            }\n            if (file && !file.dir) {\n                delete this.files[name];\n            } else {\n                var kids = this.filter(function (relativePath, file) {\n                    return file.name.slice(0, name.length) === name;\n                });\n                for (var i = 0; i < kids.length; i++) {\n                    delete this.files[kids[i].name];\n                }\n            }\n            return this;\n        },\n        generate: function () {\n            throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.');\n        },\n        generateInternalStream: function (options) {\n            var worker, opts = {};\n            try {\n                opts = utils.extend(options || {}, {\n                    streamFiles: false,\n                    compression: 'STORE',\n                    compressionOptions: null,\n                    type: '',\n                    platform: 'DOS',\n                    comment: null,\n                    mimeType: 'application/zip',\n                    encodeFileName: utf8.utf8encode\n                });\n                opts.type = opts.type.toLowerCase();\n                opts.compression = opts.compression.toUpperCase();\n                if (opts.type === 'binarystring') {\n                    opts.type = 'string';\n                }\n                if (!opts.type) {\n                    throw new Error('No output type specified.');\n                }\n                utils.checkSupport(opts.type);\n                if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {\n                    opts.platform = 'UNIX';\n                }\n                if (opts.platform === 'win32') {\n                    opts.platform = 'DOS';\n                }\n                var comment = opts.comment || this.comment || '';\n                worker = generate.generateWorker(this, opts, comment);\n            } catch (e) {\n                worker = new GenericWorker('error');\n                worker.error(e);\n            }\n            return new StreamHelper(worker, opts.type || 'string', opts.mimeType);\n        },\n        generateAsync: function (options, onUpdate) {\n            return this.generateInternalStream(options).accumulate(onUpdate);\n        },\n        generateNodeStream: function (options, onUpdate) {\n            options = options || {};\n            if (!options.type) {\n                options.type = 'nodebuffer';\n            }\n            return this.generateInternalStream(options).toNodejsStream(onUpdate);\n        }\n    };\n\n    return out;\n\n});\ndefine('skylark-jszip/reader/ArrayReader',[\n    \"skylark-io-readers/array-reader\"\n], function (ArrayReader) {\n    'use strict';\n\n    return ArrayReader;\n\n});\ndefine('skylark-jszip/reader/StringReader',[\n    \"skylark-io-readers/string-reader\"\n], function (StringReader) {\n    'use strict';\n\n    return StringReader;\n\n});\ndefine('skylark-jszip/reader/NodeBufferReader',[\n    \"skylark-io-readers/buffer-reader\"\n], function (BufferReader) {\n    'use strict';\n\n    return BufferReader;\n\n});\ndefine('skylark-jszip/reader/Uint8ArrayReader',[\n    \"skylark-io-readers/uint8-array-reader\"\n], function (Uint8ArrayReader) {\n    'use strict';\n\n    return Uint8ArrayReader;\n\n});\ndefine('skylark-jszip/reader/readerFor',[\n    '../utils',\n    '../support',\n    './ArrayReader',\n    './StringReader',\n    './NodeBufferReader',\n    './Uint8ArrayReader'\n], function (utils, support, ArrayReader, StringReader, NodeBufferReader, Uint8ArrayReader) {\n    'use strict';\n\n    function readerFor(data) {\n        var type = utils.getTypeOf(data);\n        utils.checkSupport(type);\n        if (type === 'string' && !support.uint8array) {\n            return new StringReader(data);\n        }\n        if (type === 'nodebuffer') {\n            return new NodeBufferReader(data);\n        }\n        if (support.uint8array) {\n            return new Uint8ArrayReader(utils.transformTo('uint8array', data));\n        }\n        return new ArrayReader(utils.transformTo('array', data));\n    }\n\n    return readerFor;\n});\ndefine('skylark-jszip/zipEntry',[\n    './reader/readerFor',\n    './utils',\n    './compressedObject',\n    './crc32',\n    './utf8',\n    './compressions',\n    './support'\n], function (readerFor, utils, CompressedObject, crc32fn, utf8, compressions, support) {\n    'use strict';\n\n    var MADE_BY_DOS = 0;\n    var MADE_BY_UNIX = 3;\n    var findCompression = function (compressionMethod) {\n        for (var method in compressions) {\n            if (!Object.prototype.hasOwnProperty.call(compressions, method)) {\n                continue;\n            }\n            if (compressions[method].magic === compressionMethod) {\n                return compressions[method];\n            }\n        }\n        return null;\n    };\n    function ZipEntry(options, loadOptions) {\n        this.options = options;\n        this.loadOptions = loadOptions;\n    }\n    ZipEntry.prototype = {\n        isEncrypted: function () {\n            return (this.bitFlag & 1) === 1;\n        },\n        useUTF8: function () {\n            return (this.bitFlag & 2048) === 2048;\n        },\n        readLocalPart: function (reader) {\n            var compression, localExtraFieldsLength;\n            reader.skip(22);\n            this.fileNameLength = reader.readInt(2);\n            localExtraFieldsLength = reader.readInt(2);\n            this.fileName = reader.readData(this.fileNameLength);\n            reader.skip(localExtraFieldsLength);\n            if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n                throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + '(compressedSize === -1 || uncompressedSize === -1)');\n            }\n            compression = findCompression(this.compressionMethod);\n            if (compression === null) {\n                throw new Error('Corrupted zip : compression ' + utils.pretty(this.compressionMethod) + ' unknown (inner file : ' + utils.transformTo('string', this.fileName) + ')');\n            }\n            this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n        },\n        readCentralPart: function (reader) {\n            this.versionMadeBy = reader.readInt(2);\n            reader.skip(2);\n            this.bitFlag = reader.readInt(2);\n            this.compressionMethod = reader.readString(2);\n            this.date = reader.readDate();\n            this.crc32 = reader.readInt(4);\n            this.compressedSize = reader.readInt(4);\n            this.uncompressedSize = reader.readInt(4);\n            var fileNameLength = reader.readInt(2);\n            this.extraFieldsLength = reader.readInt(2);\n            this.fileCommentLength = reader.readInt(2);\n            this.diskNumberStart = reader.readInt(2);\n            this.internalFileAttributes = reader.readInt(2);\n            this.externalFileAttributes = reader.readInt(4);\n            this.localHeaderOffset = reader.readInt(4);\n            if (this.isEncrypted()) {\n                throw new Error('Encrypted zip are not supported');\n            }\n            reader.skip(fileNameLength);\n            this.readExtraFields(reader);\n            this.parseZIP64ExtraField(reader);\n            this.fileComment = reader.readData(this.fileCommentLength);\n        },\n        processAttributes: function () {\n            this.unixPermissions = null;\n            this.dosPermissions = null;\n            var madeBy = this.versionMadeBy >> 8;\n            this.dir = this.externalFileAttributes & 16 ? true : false;\n            if (madeBy === MADE_BY_DOS) {\n                this.dosPermissions = this.externalFileAttributes & 63;\n            }\n            if (madeBy === MADE_BY_UNIX) {\n                this.unixPermissions = this.externalFileAttributes >> 16 & 65535;\n            }\n            if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n                this.dir = true;\n            }\n        },\n        parseZIP64ExtraField: function () {\n            if (!this.extraFields[1]) {\n                return;\n            }\n            var extraReader = readerFor(this.extraFields[1].value);\n            if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n                this.uncompressedSize = extraReader.readInt(8);\n            }\n            if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n                this.compressedSize = extraReader.readInt(8);\n            }\n            if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n                this.localHeaderOffset = extraReader.readInt(8);\n            }\n            if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n                this.diskNumberStart = extraReader.readInt(4);\n            }\n        },\n        readExtraFields: function (reader) {\n            var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;\n            if (!this.extraFields) {\n                this.extraFields = {};\n            }\n            while (reader.index + 4 < end) {\n                extraFieldId = reader.readInt(2);\n                extraFieldLength = reader.readInt(2);\n                extraFieldValue = reader.readData(extraFieldLength);\n                this.extraFields[extraFieldId] = {\n                    id: extraFieldId,\n                    length: extraFieldLength,\n                    value: extraFieldValue\n                };\n            }\n            reader.setIndex(end);\n        },\n        handleUTF8: function () {\n            var decodeParamType = support.uint8array ? 'uint8array' : 'array';\n            if (this.useUTF8()) {\n                this.fileNameStr = utf8.utf8decode(this.fileName);\n                this.fileCommentStr = utf8.utf8decode(this.fileComment);\n            } else {\n                var upath = this.findExtraFieldUnicodePath();\n                if (upath !== null) {\n                    this.fileNameStr = upath;\n                } else {\n                    var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);\n                    this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n                }\n                var ucomment = this.findExtraFieldUnicodeComment();\n                if (ucomment !== null) {\n                    this.fileCommentStr = ucomment;\n                } else {\n                    var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);\n                    this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n                }\n            }\n        },\n        findExtraFieldUnicodePath: function () {\n            var upathField = this.extraFields[28789];\n            if (upathField) {\n                var extraReader = readerFor(upathField.value);\n                if (extraReader.readInt(1) !== 1) {\n                    return null;\n                }\n                if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                    return null;\n                }\n                return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n            }\n            return null;\n        },\n        findExtraFieldUnicodeComment: function () {\n            var ucommentField = this.extraFields[25461];\n            if (ucommentField) {\n                var extraReader = readerFor(ucommentField.value);\n                if (extraReader.readInt(1) !== 1) {\n                    return null;\n                }\n                if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                    return null;\n                }\n                return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n            }\n            return null;\n        }\n    };\n\n    return ZipEntry;\n\n});\ndefine('skylark-jszip/zipEntries',[\n    './reader/readerFor',\n    './utils',\n    './signature',\n    './zipEntry',\n    './support'\n], function (readerFor, utils, sig, ZipEntry, support) {\n    'use strict';\n\n    function ZipEntries(loadOptions) {\n        this.files = [];\n        this.loadOptions = loadOptions;\n    }\n    ZipEntries.prototype = {\n        checkSignature: function (expectedSignature) {\n            if (!this.reader.readAndCheckSignature(expectedSignature)) {\n                this.reader.index -= 4;\n                var signature = this.reader.readString(4);\n                throw new Error('Corrupted zip or bug: unexpected signature ' + '(' + utils.pretty(signature) + ', expected ' + utils.pretty(expectedSignature) + ')');\n            }\n        },\n        isSignature: function (askedIndex, expectedSignature) {\n            var currentIndex = this.reader.index;\n            this.reader.setIndex(askedIndex);\n            var signature = this.reader.readString(4);\n            var result = signature === expectedSignature;\n            this.reader.setIndex(currentIndex);\n            return result;\n        },\n        readBlockEndOfCentral: function () {\n            this.diskNumber = this.reader.readInt(2);\n            this.diskWithCentralDirStart = this.reader.readInt(2);\n            this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n            this.centralDirRecords = this.reader.readInt(2);\n            this.centralDirSize = this.reader.readInt(4);\n            this.centralDirOffset = this.reader.readInt(4);\n            this.zipCommentLength = this.reader.readInt(2);\n            var zipComment = this.reader.readData(this.zipCommentLength);\n            var decodeParamType = support.uint8array ? 'uint8array' : 'array';\n            var decodeContent = utils.transformTo(decodeParamType, zipComment);\n            this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n        },\n        readBlockZip64EndOfCentral: function () {\n            this.zip64EndOfCentralSize = this.reader.readInt(8);\n            this.reader.skip(4);\n            this.diskNumber = this.reader.readInt(4);\n            this.diskWithCentralDirStart = this.reader.readInt(4);\n            this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n            this.centralDirRecords = this.reader.readInt(8);\n            this.centralDirSize = this.reader.readInt(8);\n            this.centralDirOffset = this.reader.readInt(8);\n            this.zip64ExtensibleData = {};\n            var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n            while (index < extraDataSize) {\n                extraFieldId = this.reader.readInt(2);\n                extraFieldLength = this.reader.readInt(4);\n                extraFieldValue = this.reader.readData(extraFieldLength);\n                this.zip64ExtensibleData[extraFieldId] = {\n                    id: extraFieldId,\n                    length: extraFieldLength,\n                    value: extraFieldValue\n                };\n            }\n        },\n        readBlockZip64EndOfCentralLocator: function () {\n            this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n            this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n            this.disksCount = this.reader.readInt(4);\n            if (this.disksCount > 1) {\n                throw new Error('Multi-volumes zip are not supported');\n            }\n        },\n        readLocalFiles: function () {\n            var i, file;\n            for (i = 0; i < this.files.length; i++) {\n                file = this.files[i];\n                this.reader.setIndex(file.localHeaderOffset);\n                this.checkSignature(sig.LOCAL_FILE_HEADER);\n                file.readLocalPart(this.reader);\n                file.handleUTF8();\n                file.processAttributes();\n            }\n        },\n        readCentralDir: function () {\n            var file;\n            this.reader.setIndex(this.centralDirOffset);\n            while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n                file = new ZipEntry({ zip64: this.zip64 }, this.loadOptions);\n                file.readCentralPart(this.reader);\n                this.files.push(file);\n            }\n            if (this.centralDirRecords !== this.files.length) {\n                if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                    throw new Error('Corrupted zip or bug: expected ' + this.centralDirRecords + ' records in central dir, got ' + this.files.length);\n                } else {\n                }\n            }\n        },\n        readEndOfCentral: function () {\n            var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n            if (offset < 0) {\n                var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n                if (isGarbage) {\n                    throw new Error(\"Can't find end of central directory : is this a zip file ? \" + 'If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html');\n                } else {\n                    throw new Error(\"Corrupted zip: can't find end of central directory\");\n                }\n            }\n            this.reader.setIndex(offset);\n            var endOfCentralDirOffset = offset;\n            this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n            this.readBlockEndOfCentral();\n            if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n                this.zip64 = true;\n                offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n                if (offset < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n                }\n                this.reader.setIndex(offset);\n                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n                this.readBlockZip64EndOfCentralLocator();\n                if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                    this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                    if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                        throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                    }\n                }\n                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                this.readBlockZip64EndOfCentral();\n            }\n            var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n            if (this.zip64) {\n                expectedEndOfCentralDirOffset += 20;\n                expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;\n            }\n            var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n            if (extraBytes > 0) {\n                if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                } else {\n                    this.reader.zero = extraBytes;\n                }\n            } else if (extraBytes < 0) {\n                throw new Error('Corrupted zip: missing ' + Math.abs(extraBytes) + ' bytes.');\n            }\n        },\n        prepareReader: function (data) {\n            this.reader = readerFor(data);\n        },\n        load: function (data) {\n            this.prepareReader(data);\n            this.readEndOfCentral();\n            this.readCentralDir();\n            this.readLocalFiles();\n        }\n    };\n    return ZipEntries;\n\n});\ndefine('skylark-jszip/load',[\n    './utils',\n    './external',\n    './utf8',\n    './zipEntries',\n    './stream/Crc32Probe'\n], function (utils, external, utf8, ZipEntries, Crc32Probe) {\n    'use strict';\n\n    function checkEntryCRC32(zipEntry) {\n        return new external.Promise(function (resolve, reject) {\n            var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n            worker.on('error', function (e) {\n                reject(e);\n            }).on('end', function () {\n                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                    reject(new Error('Corrupted zip : CRC32 mismatch'));\n                } else {\n                    resolve();\n                }\n            }).resume();\n        });\n    }\n    function load(data, options) {\n        var zip = this;\n        options = utils.extend(options || {}, {\n            base64: false,\n            checkCRC32: false,\n            optimizedBinaryString: false,\n            createFolders: false,\n            decodeFileName: utf8.utf8decode\n        });\n        ///if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        ///    return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n        ///}\n        return utils.prepareContent('the loaded zip file', data, true, options.optimizedBinaryString, options.base64).then(function (data) {\n            var zipEntries = new ZipEntries(options);\n            zipEntries.load(data);\n            return zipEntries;\n        }).then(function checkCRC32(zipEntries) {\n            var promises = [external.Promise.resolve(zipEntries)];\n            var files = zipEntries.files;\n            if (options.checkCRC32) {\n                for (var i = 0; i < files.length; i++) {\n                    promises.push(checkEntryCRC32(files[i]));\n                }\n            }\n            return external.Promise.all(promises);\n        }).then(function addFiles(results) {\n            var zipEntries = results.shift();\n            var files = zipEntries.files;\n            for (var i = 0; i < files.length; i++) {\n                var input = files[i];\n                var unsafeName = input.fileNameStr;\n                var safeName = utils.resolve(input.fileNameStr);\n                zip.file(safeName, input.decompressed, {\n                    binary: true,\n                    optimizedBinaryString: true,\n                    date: input.date,\n                    dir: input.dir,\n                    comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n                    unixPermissions: input.unixPermissions,\n                    dosPermissions: input.dosPermissions,\n                    createFolders: options.createFolders\n                });\n                if (!input.dir) {\n                    zip.file(safeName).unsafeOriginalName = unsafeName;\n                }\n            }\n            if (zipEntries.zipComment.length) {\n                zip.comment = zipEntries.zipComment;\n            }\n            return zip;\n        });\n    };\n\n    return load;\n});\ndefine('skylark-jszip/JSZip',[\n    './object',\n    './load',\n    './support',\n    './defaults',\n    './external'\n], function (object, load, support, defaults, external) {\n    'use strict';\n\n    function JSZip() {\n        if (!(this instanceof JSZip)) {\n            return new JSZip();\n        }\n        if (arguments.length) {\n            throw new Error('The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.');\n        }\n        this.files = Object.create(null);\n        this.comment = null;\n        this.root = '';\n        this.clone = function () {\n            var newObj = new JSZip();\n            for (var i in this) {\n                if (typeof this[i] !== 'function') {\n                    newObj[i] = this[i];\n                }\n            }\n            return newObj;\n        };\n    }\n    JSZip.prototype = object;\n    JSZip.prototype.loadAsync = load;\n    JSZip.support = support;\n    JSZip.defaults = defaults;\n    JSZip.version = '3.10.1';\n    JSZip.loadAsync = function (content, options) {\n        return new JSZip().loadAsync(content, options);\n    };\n    JSZip.external = external;\n    return JSZip;\n\n});\ndefine('skylark-jszip/main',[\r\n    \"skylark-langx-ns\",\r\n    \"./JSZip\"\r\n], function(skylark, JSZip) {\r\n\r\n    var zip = function(data, options) {\r\n        var zip =  new JSZip();\r\n        if (arguments.length>0) {\r\n        \treturn zip.loadAsync(data, options);\r\n        } else {\r\n        \treturn zip;\r\n        }\r\n    };\r\n\r\n    zip.ZipFile = JSZip\r\n\r\n    return skylark.attach(\"intg.jszip\", zip);\r\n\r\n});\ndefine('skylark-jszip', ['skylark-jszip/main'], function (main) { return main; });\n\n"]}