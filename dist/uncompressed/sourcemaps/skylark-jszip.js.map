{"version":3,"sources":["skylark-jszip.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-jszip.js","sourcesContent":["define('skylark-langx-binary/Buffer',[\r\n  \"./binary\",\r\n  \"./base64\",\r\n  \"./ieee754\"\r\n],function(binary,base64,ieee754){\r\n  /*!\r\n   * The buffer module from node.js, for the browser.\r\n   *\r\n   * @author   Feross Aboukhadijeh <https://feross.org>\r\n   * @license  MIT\r\n   */\r\n  /* eslint-disable no-proto */\r\n\r\n  'use strict'\r\n\r\n\r\n  Buffer.INSPECT_MAX_BYTES = 50\r\n\r\n  var K_MAX_LENGTH = 0x7fffffff\r\n  Buffer.kMaxLength = K_MAX_LENGTH\r\n\r\n  /**\r\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n   *   === true    Use Uint8Array implementation (fastest)\r\n   *   === false   Print warning and recommend using `buffer` v4.x which has an Object\r\n   *               implementation (most compatible, even IE6)\r\n   *\r\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n   * Opera 11.6+, iOS 4.2+.\r\n   *\r\n   * We report that the browser does not support typed arrays if the are not subclassable\r\n   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\r\n   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\r\n   * for __proto__ and has a buggy typed array implementation.\r\n   */\r\n  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\r\n\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\r\n      typeof console.error === 'function') {\r\n    console.error(\r\n      'This browser lacks typed array (Uint8Array) support which is required by ' +\r\n      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\r\n    )\r\n  }\r\n\r\n  function typedArraySupport () {\r\n    // Can typed array instances can be augmented?\r\n    try {\r\n      var arr = new Uint8Array(1)\r\n      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n      return arr.foo() === 42\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Buffer.prototype, 'parent', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.buffer\r\n    }\r\n  })\r\n\r\n  Object.defineProperty(Buffer.prototype, 'offset', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.byteOffset\r\n    }\r\n  })\r\n\r\n  function createBuffer (length) {\r\n    if (length > K_MAX_LENGTH) {\r\n      throw new RangeError('Invalid typed array length')\r\n    }\r\n    // Return an augmented `Uint8Array` instance\r\n    var buf = new Uint8Array(length)\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  /**\r\n   * The Buffer constructor returns instances of `Uint8Array` that have their\r\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n   * returns a single octet.\r\n   *\r\n   * The `Uint8Array` prototype remains unmodified.\r\n   */\r\n\r\n  function Buffer (arg, encodingOrOffset, length) {\r\n    // Common case.\r\n    if (typeof arg === 'number') {\r\n      if (typeof encodingOrOffset === 'string') {\r\n        throw new Error(\r\n          'If encoding is specified then the first argument must be a string'\r\n        )\r\n      }\r\n      return allocUnsafe(arg)\r\n    }\r\n    return from(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: false\r\n    })\r\n  }\r\n\r\n  Buffer.poolSize = 8192 // not used by this implementation\r\n\r\n  function from (value, encodingOrOffset, length) {\r\n    if (typeof value === 'number') {\r\n      throw new TypeError('\"value\" argument must not be a number')\r\n    }\r\n\r\n    if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {\r\n      return fromArrayBuffer(value, encodingOrOffset, length)\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return fromString(value, encodingOrOffset)\r\n    }\r\n\r\n    return fromObject(value)\r\n  }\r\n\r\n  /**\r\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n   * if value is a number.\r\n   * Buffer.from(str[, encoding])\r\n   * Buffer.from(array)\r\n   * Buffer.from(buffer)\r\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n   **/\r\n  Buffer.from = function (value, encodingOrOffset, length) {\r\n    return from(value, encodingOrOffset, length)\r\n  }\r\n\r\n  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\r\n  // https://github.com/feross/buffer/pull/148\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n\r\n  function assertSize (size) {\r\n    if (typeof size !== 'number') {\r\n      throw new TypeError('\"size\" argument must be of type number')\r\n    } else if (size < 0) {\r\n      throw new RangeError('\"size\" argument must not be negative')\r\n    }\r\n  }\r\n\r\n  function alloc (size, fill, encoding) {\r\n    assertSize(size)\r\n    if (size <= 0) {\r\n      return createBuffer(size)\r\n    }\r\n    if (fill !== undefined) {\r\n      // Only pay attention to encoding if it's a string. This\r\n      // prevents accidentally sending in a number that would\r\n      // be interpretted as a start offset.\r\n      return typeof encoding === 'string'\r\n        ? createBuffer(size).fill(fill, encoding)\r\n        : createBuffer(size).fill(fill)\r\n    }\r\n    return createBuffer(size)\r\n  }\r\n\r\n  /**\r\n   * Creates a new filled Buffer instance.\r\n   * alloc(size[, fill[, encoding]])\r\n   **/\r\n  Buffer.alloc = function (size, fill, encoding) {\r\n    return alloc(size, fill, encoding)\r\n  }\r\n\r\n  function allocUnsafe (size) {\r\n    assertSize(size)\r\n    return createBuffer(size < 0 ? 0 : checked(size) | 0)\r\n  }\r\n\r\n  /**\r\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n   * */\r\n  Buffer.allocUnsafe = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n  /**\r\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n   */\r\n  Buffer.allocUnsafeSlow = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n\r\n  function fromString (string, encoding) {\r\n    if (typeof encoding !== 'string' || encoding === '') {\r\n      encoding = 'utf8'\r\n    }\r\n\r\n    if (!Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n\r\n    var length = byteLength(string, encoding) | 0\r\n    var buf = createBuffer(length)\r\n\r\n    var actual = buf.write(string, encoding)\r\n\r\n    if (actual !== length) {\r\n      // Writing a hex string, for example, that contains invalid characters will\r\n      // cause everything after the first invalid character to be ignored. (e.g.\r\n      // 'abxxcd' will be treated as 'ab')\r\n      buf = buf.slice(0, actual)\r\n    }\r\n\r\n    return buf\r\n  }\r\n\r\n  function fromArrayLike (array) {\r\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n    var buf = createBuffer(length)\r\n    for (var i = 0; i < length; i += 1) {\r\n      buf[i] = array[i] & 255\r\n    }\r\n    return buf\r\n  }\r\n\r\n  function fromArrayBuffer (array, byteOffset, length) {\r\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n      throw new RangeError('\"offset\" is outside of buffer bounds')\r\n    }\r\n\r\n    if (array.byteLength < byteOffset + (length || 0)) {\r\n      throw new RangeError('\"length\" is outside of buffer bounds')\r\n    }\r\n\r\n    var buf\r\n    if (byteOffset === undefined && length === undefined) {\r\n      buf = new Uint8Array(array)\r\n    } else if (length === undefined) {\r\n      buf = new Uint8Array(array, byteOffset)\r\n    } else {\r\n      buf = new Uint8Array(array, byteOffset, length)\r\n    }\r\n\r\n    // Return an augmented `Uint8Array` instance\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  function fromObject (obj) {\r\n    if (Buffer.isBuffer(obj)) {\r\n      var len = checked(obj.length) | 0\r\n      var buf = createBuffer(len)\r\n\r\n      if (buf.length === 0) {\r\n        return buf\r\n      }\r\n\r\n      obj.copy(buf, 0, 0, len)\r\n      return buf\r\n    }\r\n\r\n    if (obj) {\r\n      if (ArrayBuffer.isView(obj) || 'length' in obj) {\r\n        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\r\n          return createBuffer(0)\r\n        }\r\n        return fromArrayLike(obj)\r\n      }\r\n\r\n      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\r\n        return fromArrayLike(obj.data)\r\n      }\r\n    }\r\n\r\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')\r\n  }\r\n\r\n  function checked (length) {\r\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\r\n    // length is NaN (which is otherwise coerced to zero.)\r\n    if (length >= K_MAX_LENGTH) {\r\n      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\r\n    }\r\n    return length | 0\r\n  }\r\n\r\n  function SlowBuffer (length) {\r\n    if (+length != length) { // eslint-disable-line eqeqeq\r\n      length = 0\r\n    }\r\n    return Buffer.alloc(+length)\r\n  }\r\n\r\n  Buffer.isBuffer = function isBuffer (b) {\r\n    return b != null && b._isBuffer === true\r\n  }\r\n\r\n  Buffer.compare = function compare (a, b) {\r\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n      throw new TypeError('Arguments must be Buffers')\r\n    }\r\n\r\n    if (a === b) return 0\r\n\r\n    var x = a.length\r\n    var y = b.length\r\n\r\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n      if (a[i] !== b[i]) {\r\n        x = a[i]\r\n        y = b[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  Buffer.isEncoding = function isEncoding (encoding) {\r\n    switch (String(encoding).toLowerCase()) {\r\n      case 'hex':\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n      case 'base64':\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return true\r\n      default:\r\n        return false\r\n    }\r\n  }\r\n\r\n  Buffer.concat = function concat (list, length) {\r\n    if (!Array.isArray(list)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n\r\n    if (list.length === 0) {\r\n      return Buffer.alloc(0)\r\n    }\r\n\r\n    var i\r\n    if (length === undefined) {\r\n      length = 0\r\n      for (i = 0; i < list.length; ++i) {\r\n        length += list[i].length\r\n      }\r\n    }\r\n\r\n    var buffer = Buffer.allocUnsafe(length)\r\n    var pos = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      var buf = list[i]\r\n      if (ArrayBuffer.isView(buf)) {\r\n        buf = Buffer.from(buf)\r\n      }\r\n      if (!Buffer.isBuffer(buf)) {\r\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n      }\r\n      buf.copy(buffer, pos)\r\n      pos += buf.length\r\n    }\r\n    return buffer\r\n  }\r\n\r\n  function byteLength (string, encoding) {\r\n    if (Buffer.isBuffer(string)) {\r\n      return string.length\r\n    }\r\n    if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {\r\n      return string.byteLength\r\n    }\r\n    if (typeof string !== 'string') {\r\n      string = '' + string\r\n    }\r\n\r\n    var len = string.length\r\n    if (len === 0) return 0\r\n\r\n    // Use a for loop to avoid recursion\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'ascii':\r\n        case 'latin1':\r\n        case 'binary':\r\n          return len\r\n        case 'utf8':\r\n        case 'utf-8':\r\n        case undefined:\r\n          return utf8ToBytes(string).length\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return len * 2\r\n        case 'hex':\r\n          return len >>> 1\r\n        case 'base64':\r\n          return base64ToBytes(string).length\r\n        default:\r\n          if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n  Buffer.byteLength = byteLength\r\n\r\n  function slowToString (encoding, start, end) {\r\n    var loweredCase = false\r\n\r\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n    // property of a typed array.\r\n\r\n    // This behaves neither like String nor Uint8Array in that we set start/end\r\n    // to their upper/lower bounds if the value passed is out of range.\r\n    // undefined is handled specially as per ECMA-262 6th Edition,\r\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n    if (start === undefined || start < 0) {\r\n      start = 0\r\n    }\r\n    // Return early if start > this.length. Done here to prevent potential uint32\r\n    // coercion fail below.\r\n    if (start > this.length) {\r\n      return ''\r\n    }\r\n\r\n    if (end === undefined || end > this.length) {\r\n      end = this.length\r\n    }\r\n\r\n    if (end <= 0) {\r\n      return ''\r\n    }\r\n\r\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n    end >>>= 0\r\n    start >>>= 0\r\n\r\n    if (end <= start) {\r\n      return ''\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    while (true) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexSlice(this, start, end)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Slice(this, start, end)\r\n\r\n        case 'ascii':\r\n          return asciiSlice(this, start, end)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Slice(this, start, end)\r\n\r\n        case 'base64':\r\n          return base64Slice(this, start, end)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return utf16leSlice(this, start, end)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = (encoding + '').toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\r\n  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\r\n  // reliably in a browserify context because there could be multiple different\r\n  // copies of the 'buffer' package in use. This method works even for Buffer\r\n  // instances that were created from another copy of the `buffer` package.\r\n  // See: https://github.com/feross/buffer/issues/154\r\n  Buffer.prototype._isBuffer = true\r\n\r\n  function swap (b, n, m) {\r\n    var i = b[n]\r\n    b[n] = b[m]\r\n    b[m] = i\r\n  }\r\n\r\n  Buffer.prototype.swap16 = function swap16 () {\r\n    var len = this.length\r\n    if (len % 2 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 2) {\r\n      swap(this, i, i + 1)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap32 = function swap32 () {\r\n    var len = this.length\r\n    if (len % 4 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 4) {\r\n      swap(this, i, i + 3)\r\n      swap(this, i + 1, i + 2)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap64 = function swap64 () {\r\n    var len = this.length\r\n    if (len % 8 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 8) {\r\n      swap(this, i, i + 7)\r\n      swap(this, i + 1, i + 6)\r\n      swap(this, i + 2, i + 5)\r\n      swap(this, i + 3, i + 4)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.toString = function toString () {\r\n    var length = this.length\r\n    if (length === 0) return ''\r\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n    return slowToString.apply(this, arguments)\r\n  }\r\n\r\n  Buffer.prototype.toLocaleString = Buffer.prototype.toString\r\n\r\n  Buffer.prototype.equals = function equals (b) {\r\n    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n    if (this === b) return true\r\n    return Buffer.compare(this, b) === 0\r\n  }\r\n\r\n  Buffer.prototype.inspect = function inspect () {\r\n    var str = ''\r\n    var max = Buffer.INSPECT_MAX_BYTES\r\n    if (this.length > 0) {\r\n      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n      if (this.length > max) str += ' ... '\r\n    }\r\n    return '<Buffer ' + str + '>'\r\n  }\r\n\r\n  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n    if (!Buffer.isBuffer(target)) {\r\n      throw new TypeError('Argument must be a Buffer')\r\n    }\r\n\r\n    if (start === undefined) {\r\n      start = 0\r\n    }\r\n    if (end === undefined) {\r\n      end = target ? target.length : 0\r\n    }\r\n    if (thisStart === undefined) {\r\n      thisStart = 0\r\n    }\r\n    if (thisEnd === undefined) {\r\n      thisEnd = this.length\r\n    }\r\n\r\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n      throw new RangeError('out of range index')\r\n    }\r\n\r\n    if (thisStart >= thisEnd && start >= end) {\r\n      return 0\r\n    }\r\n    if (thisStart >= thisEnd) {\r\n      return -1\r\n    }\r\n    if (start >= end) {\r\n      return 1\r\n    }\r\n\r\n    start >>>= 0\r\n    end >>>= 0\r\n    thisStart >>>= 0\r\n    thisEnd >>>= 0\r\n\r\n    if (this === target) return 0\r\n\r\n    var x = thisEnd - thisStart\r\n    var y = end - start\r\n    var len = Math.min(x, y)\r\n\r\n    var thisCopy = this.slice(thisStart, thisEnd)\r\n    var targetCopy = target.slice(start, end)\r\n\r\n    for (var i = 0; i < len; ++i) {\r\n      if (thisCopy[i] !== targetCopy[i]) {\r\n        x = thisCopy[i]\r\n        y = targetCopy[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n  //\r\n  // Arguments:\r\n  // - buffer - a Buffer to search\r\n  // - val - a string, Buffer, or number\r\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\r\n  // - encoding - an optional encoding, relevant is val is a string\r\n  // - dir - true for indexOf, false for lastIndexOf\r\n  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n    // Empty buffer means no match\r\n    if (buffer.length === 0) return -1\r\n\r\n    // Normalize byteOffset\r\n    if (typeof byteOffset === 'string') {\r\n      encoding = byteOffset\r\n      byteOffset = 0\r\n    } else if (byteOffset > 0x7fffffff) {\r\n      byteOffset = 0x7fffffff\r\n    } else if (byteOffset < -0x80000000) {\r\n      byteOffset = -0x80000000\r\n    }\r\n    byteOffset = +byteOffset  // Coerce to Number.\r\n    if (numberIsNaN(byteOffset)) {\r\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n      byteOffset = dir ? 0 : (buffer.length - 1)\r\n    }\r\n\r\n    // Normalize byteOffset: negative offsets start from the end of the buffer\r\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n    if (byteOffset >= buffer.length) {\r\n      if (dir) return -1\r\n      else byteOffset = buffer.length - 1\r\n    } else if (byteOffset < 0) {\r\n      if (dir) byteOffset = 0\r\n      else return -1\r\n    }\r\n\r\n    // Normalize val\r\n    if (typeof val === 'string') {\r\n      val = Buffer.from(val, encoding)\r\n    }\r\n\r\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n    if (Buffer.isBuffer(val)) {\r\n      // Special case: looking for empty string/buffer always fails\r\n      if (val.length === 0) {\r\n        return -1\r\n      }\r\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n    } else if (typeof val === 'number') {\r\n      val = val & 0xFF // Search for a byte value [0-255]\r\n      if (typeof Uint8Array.prototype.indexOf === 'function') {\r\n        if (dir) {\r\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n        } else {\r\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n        }\r\n      }\r\n      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n    }\r\n\r\n    throw new TypeError('val must be string, number or Buffer')\r\n  }\r\n\r\n  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n    var indexSize = 1\r\n    var arrLength = arr.length\r\n    var valLength = val.length\r\n\r\n    if (encoding !== undefined) {\r\n      encoding = String(encoding).toLowerCase()\r\n      if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n          encoding === 'utf16le' || encoding === 'utf-16le') {\r\n        if (arr.length < 2 || val.length < 2) {\r\n          return -1\r\n        }\r\n        indexSize = 2\r\n        arrLength /= 2\r\n        valLength /= 2\r\n        byteOffset /= 2\r\n      }\r\n    }\r\n\r\n    function read (buf, i) {\r\n      if (indexSize === 1) {\r\n        return buf[i]\r\n      } else {\r\n        return buf.readUInt16BE(i * indexSize)\r\n      }\r\n    }\r\n\r\n    var i\r\n    if (dir) {\r\n      var foundIndex = -1\r\n      for (i = byteOffset; i < arrLength; i++) {\r\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n          if (foundIndex === -1) foundIndex = i\r\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n        } else {\r\n          if (foundIndex !== -1) i -= i - foundIndex\r\n          foundIndex = -1\r\n        }\r\n      }\r\n    } else {\r\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n      for (i = byteOffset; i >= 0; i--) {\r\n        var found = true\r\n        for (var j = 0; j < valLength; j++) {\r\n          if (read(arr, i + j) !== read(val, j)) {\r\n            found = false\r\n            break\r\n          }\r\n        }\r\n        if (found) return i\r\n      }\r\n    }\r\n\r\n    return -1\r\n  }\r\n\r\n  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n    return this.indexOf(val, byteOffset, encoding) !== -1\r\n  }\r\n\r\n  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n  }\r\n\r\n  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n  }\r\n\r\n  function hexWrite (buf, string, offset, length) {\r\n    offset = Number(offset) || 0\r\n    var remaining = buf.length - offset\r\n    if (!length) {\r\n      length = remaining\r\n    } else {\r\n      length = Number(length)\r\n      if (length > remaining) {\r\n        length = remaining\r\n      }\r\n    }\r\n\r\n    var strLen = string.length\r\n\r\n    if (length > strLen / 2) {\r\n      length = strLen / 2\r\n    }\r\n    for (var i = 0; i < length; ++i) {\r\n      var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n      if (numberIsNaN(parsed)) return i\r\n      buf[offset + i] = parsed\r\n    }\r\n    return i\r\n  }\r\n\r\n  function utf8Write (buf, string, offset, length) {\r\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  function asciiWrite (buf, string, offset, length) {\r\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function latin1Write (buf, string, offset, length) {\r\n    return asciiWrite(buf, string, offset, length)\r\n  }\r\n\r\n  function base64Write (buf, string, offset, length) {\r\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function ucs2Write (buf, string, offset, length) {\r\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  Buffer.prototype.write = function write (string, offset, length, encoding) {\r\n    // Buffer#write(string)\r\n    if (offset === undefined) {\r\n      encoding = 'utf8'\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, encoding)\r\n    } else if (length === undefined && typeof offset === 'string') {\r\n      encoding = offset\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, offset[, length][, encoding])\r\n    } else if (isFinite(offset)) {\r\n      offset = offset >>> 0\r\n      if (isFinite(length)) {\r\n        length = length >>> 0\r\n        if (encoding === undefined) encoding = 'utf8'\r\n      } else {\r\n        encoding = length\r\n        length = undefined\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n      )\r\n    }\r\n\r\n    var remaining = this.length - offset\r\n    if (length === undefined || length > remaining) length = remaining\r\n\r\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n      throw new RangeError('Attempt to write outside buffer bounds')\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexWrite(this, string, offset, length)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Write(this, string, offset, length)\r\n\r\n        case 'ascii':\r\n          return asciiWrite(this, string, offset, length)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Write(this, string, offset, length)\r\n\r\n        case 'base64':\r\n          // Warning: maxLength not taken into account in base64Write\r\n          return base64Write(this, string, offset, length)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return ucs2Write(this, string, offset, length)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  Buffer.prototype.toJSON = function toJSON () {\r\n    return {\r\n      type: 'Buffer',\r\n      data: Array.prototype.slice.call(this._arr || this, 0)\r\n    }\r\n  }\r\n\r\n  function base64Slice (buf, start, end) {\r\n    if (start === 0 && end === buf.length) {\r\n      return base64.fromByteArray(buf)\r\n    } else {\r\n      return base64.fromByteArray(buf.slice(start, end))\r\n    }\r\n  }\r\n\r\n  function utf8Slice (buf, start, end) {\r\n    end = Math.min(buf.length, end)\r\n    var res = []\r\n\r\n    var i = start\r\n    while (i < end) {\r\n      var firstByte = buf[i]\r\n      var codePoint = null\r\n      var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n        : (firstByte > 0xDF) ? 3\r\n        : (firstByte > 0xBF) ? 2\r\n        : 1\r\n\r\n      if (i + bytesPerSequence <= end) {\r\n        var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n        switch (bytesPerSequence) {\r\n          case 1:\r\n            if (firstByte < 0x80) {\r\n              codePoint = firstByte\r\n            }\r\n            break\r\n          case 2:\r\n            secondByte = buf[i + 1]\r\n            if ((secondByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n              if (tempCodePoint > 0x7F) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 3:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 4:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            fourthByte = buf[i + 3]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n        }\r\n      }\r\n\r\n      if (codePoint === null) {\r\n        // we did not generate a valid codePoint so insert a\r\n        // replacement char (U+FFFD) and advance only 1 byte\r\n        codePoint = 0xFFFD\r\n        bytesPerSequence = 1\r\n      } else if (codePoint > 0xFFFF) {\r\n        // encode to utf16 (surrogate pair dance)\r\n        codePoint -= 0x10000\r\n        res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n        codePoint = 0xDC00 | codePoint & 0x3FF\r\n      }\r\n\r\n      res.push(codePoint)\r\n      i += bytesPerSequence\r\n    }\r\n\r\n    return decodeCodePointsArray(res)\r\n  }\r\n\r\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n  // the lowest limit is Chrome, with 0x10000 args.\r\n  // We go 1 magnitude less, for safety\r\n  var MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\n  function decodeCodePointsArray (codePoints) {\r\n    var len = codePoints.length\r\n    if (len <= MAX_ARGUMENTS_LENGTH) {\r\n      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n    }\r\n\r\n    // Decode in chunks to avoid \"call stack size exceeded\".\r\n    var res = ''\r\n    var i = 0\r\n    while (i < len) {\r\n      res += String.fromCharCode.apply(\r\n        String,\r\n        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n      )\r\n    }\r\n    return res\r\n  }\r\n\r\n  function asciiSlice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i] & 0x7F)\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function latin1Slice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i])\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function hexSlice (buf, start, end) {\r\n    var len = buf.length\r\n\r\n    if (!start || start < 0) start = 0\r\n    if (!end || end < 0 || end > len) end = len\r\n\r\n    var out = ''\r\n    for (var i = start; i < end; ++i) {\r\n      out += toHex(buf[i])\r\n    }\r\n    return out\r\n  }\r\n\r\n  function utf16leSlice (buf, start, end) {\r\n    var bytes = buf.slice(start, end)\r\n    var res = ''\r\n    for (var i = 0; i < bytes.length; i += 2) {\r\n      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\r\n    }\r\n    return res\r\n  }\r\n\r\n  Buffer.prototype.slice = function slice (start, end) {\r\n    var len = this.length\r\n    start = ~~start\r\n    end = end === undefined ? len : ~~end\r\n\r\n    if (start < 0) {\r\n      start += len\r\n      if (start < 0) start = 0\r\n    } else if (start > len) {\r\n      start = len\r\n    }\r\n\r\n    if (end < 0) {\r\n      end += len\r\n      if (end < 0) end = 0\r\n    } else if (end > len) {\r\n      end = len\r\n    }\r\n\r\n    if (end < start) end = start\r\n\r\n    var newBuf = this.subarray(start, end)\r\n    // Return an augmented `Uint8Array` instance\r\n    newBuf.__proto__ = Buffer.prototype\r\n    return newBuf\r\n  }\r\n\r\n  /*\r\n   * Need to make sure that buffer isn't trying to write out of bounds.\r\n   */\r\n  function checkOffset (offset, ext, length) {\r\n    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n  }\r\n\r\n  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      checkOffset(offset, byteLength, this.length)\r\n    }\r\n\r\n    var val = this[offset + --byteLength]\r\n    var mul = 1\r\n    while (byteLength > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --byteLength] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    return this[offset]\r\n  }\r\n\r\n  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return this[offset] | (this[offset + 1] << 8)\r\n  }\r\n\r\n  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return (this[offset] << 8) | this[offset + 1]\r\n  }\r\n\r\n  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return ((this[offset]) |\r\n        (this[offset + 1] << 8) |\r\n        (this[offset + 2] << 16)) +\r\n        (this[offset + 3] * 0x1000000)\r\n  }\r\n\r\n  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] * 0x1000000) +\r\n      ((this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var i = byteLength\r\n    var mul = 1\r\n    var val = this[offset + --i]\r\n    while (i > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    if (!(this[offset] & 0x80)) return (this[offset])\r\n    return ((0xff - this[offset] + 1) * -1)\r\n  }\r\n\r\n  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset] | (this[offset + 1] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset + 1] | (this[offset] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16) |\r\n      (this[offset + 3] << 24)\r\n  }\r\n\r\n  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] << 24) |\r\n      (this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      (this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, true, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, false, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, true, 52, 8)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, false, 52, 8)\r\n  }\r\n\r\n  function checkInt (buf, value, offset, ext, max, min) {\r\n    if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var mul = 1\r\n    var i = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = 0\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n    if (value < 0) value = 0xff + value + 1\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    if (value < 0) value = 0xffffffff + value + 1\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  function checkIEEE754 (buf, value, offset, ext, max, min) {\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n    if (offset < 0) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  function writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  function writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n    return offset + 8\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\n  Buffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\r\n    if (!start) start = 0\r\n    if (!end && end !== 0) end = this.length\r\n    if (targetStart >= target.length) targetStart = target.length\r\n    if (!targetStart) targetStart = 0\r\n    if (end > 0 && end < start) end = start\r\n\r\n    // Copy 0 bytes; we're done\r\n    if (end === start) return 0\r\n    if (target.length === 0 || this.length === 0) return 0\r\n\r\n    // Fatal error conditions\r\n    if (targetStart < 0) {\r\n      throw new RangeError('targetStart out of bounds')\r\n    }\r\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\r\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n    // Are we oob?\r\n    if (end > this.length) end = this.length\r\n    if (target.length - targetStart < end - start) {\r\n      end = target.length - targetStart + start\r\n    }\r\n\r\n    var len = end - start\r\n\r\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\r\n      // Use built-in when available, missing from IE11\r\n      this.copyWithin(targetStart, start, end)\r\n    } else if (this === target && start < targetStart && targetStart < end) {\r\n      // descending copy from end\r\n      for (var i = len - 1; i >= 0; --i) {\r\n        target[i + targetStart] = this[i + start]\r\n      }\r\n    } else {\r\n      Uint8Array.prototype.set.call(\r\n        target,\r\n        this.subarray(start, end),\r\n        targetStart\r\n      )\r\n    }\r\n\r\n    return len\r\n  }\r\n\r\n  // Usage:\r\n  //    buffer.fill(number[, offset[, end]])\r\n  //    buffer.fill(buffer[, offset[, end]])\r\n  //    buffer.fill(string[, offset[, end]][, encoding])\r\n  Buffer.prototype.fill = function fill (val, start, end, encoding) {\r\n    // Handle string cases:\r\n    if (typeof val === 'string') {\r\n      if (typeof start === 'string') {\r\n        encoding = start\r\n        start = 0\r\n        end = this.length\r\n      } else if (typeof end === 'string') {\r\n        encoding = end\r\n        end = this.length\r\n      }\r\n      if (encoding !== undefined && typeof encoding !== 'string') {\r\n        throw new TypeError('encoding must be a string')\r\n      }\r\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n        throw new TypeError('Unknown encoding: ' + encoding)\r\n      }\r\n      if (val.length === 1) {\r\n        var code = val.charCodeAt(0)\r\n        if ((encoding === 'utf8' && code < 128) ||\r\n            encoding === 'latin1') {\r\n          // Fast path: If `val` fits into a single byte, use that numeric value.\r\n          val = code\r\n        }\r\n      }\r\n    } else if (typeof val === 'number') {\r\n      val = val & 255\r\n    }\r\n\r\n    // Invalid ranges are not set to a default, so can range check early.\r\n    if (start < 0 || this.length < start || this.length < end) {\r\n      throw new RangeError('Out of range index')\r\n    }\r\n\r\n    if (end <= start) {\r\n      return this\r\n    }\r\n\r\n    start = start >>> 0\r\n    end = end === undefined ? this.length : end >>> 0\r\n\r\n    if (!val) val = 0\r\n\r\n    var i\r\n    if (typeof val === 'number') {\r\n      for (i = start; i < end; ++i) {\r\n        this[i] = val\r\n      }\r\n    } else {\r\n      var bytes = Buffer.isBuffer(val)\r\n        ? val\r\n        : new Buffer(val, encoding)\r\n      var len = bytes.length\r\n      if (len === 0) {\r\n        throw new TypeError('The value \"' + val +\r\n          '\" is invalid for argument \"value\"')\r\n      }\r\n      for (i = 0; i < end - start; ++i) {\r\n        this[i + start] = bytes[i % len]\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // HELPER FUNCTIONS\r\n  // ================\r\n\r\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\r\n\r\n  function base64clean (str) {\r\n    // Node takes equal signs as end of the Base64 encoding\r\n    str = str.split('=')[0]\r\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n    str = str.trim().replace(INVALID_BASE64_RE, '')\r\n    // Node converts strings with length < 2 to ''\r\n    if (str.length < 2) return ''\r\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n    while (str.length % 4 !== 0) {\r\n      str = str + '='\r\n    }\r\n    return str\r\n  }\r\n\r\n  function toHex (n) {\r\n    if (n < 16) return '0' + n.toString(16)\r\n    return n.toString(16)\r\n  }\r\n\r\n  function utf8ToBytes (string, units) {\r\n    units = units || Infinity\r\n    var codePoint\r\n    var length = string.length\r\n    var leadSurrogate = null\r\n    var bytes = []\r\n\r\n    for (var i = 0; i < length; ++i) {\r\n      codePoint = string.charCodeAt(i)\r\n\r\n      // is surrogate component\r\n      if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n        // last char was a lead\r\n        if (!leadSurrogate) {\r\n          // no lead yet\r\n          if (codePoint > 0xDBFF) {\r\n            // unexpected trail\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          } else if (i + 1 === length) {\r\n            // unpaired lead\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          }\r\n\r\n          // valid lead\r\n          leadSurrogate = codePoint\r\n\r\n          continue\r\n        }\r\n\r\n        // 2 leads in a row\r\n        if (codePoint < 0xDC00) {\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          leadSurrogate = codePoint\r\n          continue\r\n        }\r\n\r\n        // valid surrogate pair\r\n        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n      } else if (leadSurrogate) {\r\n        // valid bmp char, but last char was a lead\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n      }\r\n\r\n      leadSurrogate = null\r\n\r\n      // encode utf8\r\n      if (codePoint < 0x80) {\r\n        if ((units -= 1) < 0) break\r\n        bytes.push(codePoint)\r\n      } else if (codePoint < 0x800) {\r\n        if ((units -= 2) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x6 | 0xC0,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x10000) {\r\n        if ((units -= 3) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0xC | 0xE0,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x110000) {\r\n        if ((units -= 4) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x12 | 0xF0,\r\n          codePoint >> 0xC & 0x3F | 0x80,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else {\r\n        throw new Error('Invalid code point')\r\n      }\r\n    }\r\n\r\n    return bytes\r\n  }\r\n\r\n  function asciiToBytes (str) {\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      // Node's code seems to be doing this and not & 0x7F..\r\n      byteArray.push(str.charCodeAt(i) & 0xFF)\r\n    }\r\n    return byteArray\r\n  }\r\n\r\n  function utf16leToBytes (str, units) {\r\n    var c, hi, lo\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      if ((units -= 2) < 0) break\r\n\r\n      c = str.charCodeAt(i)\r\n      hi = c >> 8\r\n      lo = c % 256\r\n      byteArray.push(lo)\r\n      byteArray.push(hi)\r\n    }\r\n\r\n    return byteArray\r\n  }\r\n\r\n  function base64ToBytes (str) {\r\n    return base64.toByteArray(base64clean(str))\r\n  }\r\n\r\n  function blitBuffer (src, dst, offset, length) {\r\n    for (var i = 0; i < length; ++i) {\r\n      if ((i + offset >= dst.length) || (i >= src.length)) break\r\n      dst[i + offset] = src[i]\r\n    }\r\n    return i\r\n  }\r\n\r\n  // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\r\n  // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\r\n  function isArrayBuffer (obj) {\r\n    return obj instanceof ArrayBuffer ||\r\n      (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\r\n        typeof obj.byteLength === 'number')\r\n  }\r\n\r\n  function numberIsNaN (obj) {\r\n    return obj !== obj // eslint-disable-line no-self-compare\r\n  }\r\n\r\n  return binary.Buffer = Buffer;\r\n\r\n});\ndefine('skylark-jszip/support',[\n    \"skylark-langx-binary/Buffer\",\n], function (Buffer) {\n    'use strict';\n    var support = {};\n\n    support.base64 = true;\n    support.array = true;\n    support.string = true;\n    support.arraybuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';\n    support.nodebuffer = support.buffer = true;///typeof Buffer !== 'undefined';\n    support.uint8array = typeof Uint8Array !== 'undefined';\n    if (typeof ArrayBuffer === 'undefined') {\n        support.blob = false;\n    } else {\n        var buffer = new ArrayBuffer(0);\n        try {\n            support.blob = new Blob([buffer], { type: 'application/zip' }).size === 0;\n        } catch (e) {\n            try {\n                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n                var builder = new Builder();\n                builder.append(buffer);\n                support.blob = builder.getBlob('application/zip').size === 0;\n            } catch (e) {\n                support.blob = false;\n            }\n        }\n    }\n\n    support.getTypeOf = function (input) {\n        if (typeof input === 'string') {\n            return 'string';\n        }\n        if (Object.prototype.toString.call(input) === '[object Array]') {\n            return 'array';\n        }\n        if (support.nodebuffer && Buffer.isBuffer(input)) {\n            return 'nodebuffer';\n        }\n        if (support.uint8array && input instanceof Uint8Array) {\n            return 'uint8array';\n        }\n        if (support.arraybuffer && input instanceof ArrayBuffer) {\n            return 'arraybuffer';\n        }\n    };\n\n    return support;\n});\ndefine('skylark-jszip/base64',[\n    './support'\n], function (support) {\n    'use strict';\n\n    var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    function encode(input) {\n        var output = [];\n        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n        var i = 0, len = input.length, remainingBytes = len;\n        var isArray = support.getTypeOf(input) !== 'string';\n        while (i < input.length) {\n            remainingBytes = len - i;\n            if (!isArray) {\n                chr1 = input.charCodeAt(i++);\n                chr2 = i < len ? input.charCodeAt(i++) : 0;\n                chr3 = i < len ? input.charCodeAt(i++) : 0;\n            } else {\n                chr1 = input[i++];\n                chr2 = i < len ? input[i++] : 0;\n                chr3 = i < len ? input[i++] : 0;\n            }\n            enc1 = chr1 >> 2;\n            enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n            enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;\n            enc4 = remainingBytes > 2 ? chr3 & 63 : 64;\n            output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n        }\n        return output.join('');\n    };\n    function decode(input) {\n        var chr1, chr2, chr3;\n        var enc1, enc2, enc3, enc4;\n        var i = 0, resultIndex = 0;\n        var dataUrlPrefix = 'data:';\n        if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n            throw new Error('Invalid base64 input, it looks like a data url.');\n        }\n        input = input.replace(/[^A-Za-z0-9+/=]/g, '');\n        var totalLength = input.length * 3 / 4;\n        if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (totalLength % 1 !== 0) {\n            throw new Error('Invalid base64 input, bad content length.');\n        }\n        var output;\n        if (support.uint8array) {\n            output = new Uint8Array(totalLength | 0);\n        } else {\n            output = new Array(totalLength | 0);\n        }\n        while (i < input.length) {\n            enc1 = _keyStr.indexOf(input.charAt(i++));\n            enc2 = _keyStr.indexOf(input.charAt(i++));\n            enc3 = _keyStr.indexOf(input.charAt(i++));\n            enc4 = _keyStr.indexOf(input.charAt(i++));\n            chr1 = enc1 << 2 | enc2 >> 4;\n            chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n            chr3 = (enc3 & 3) << 6 | enc4;\n            output[resultIndex++] = chr1;\n            if (enc3 !== 64) {\n                output[resultIndex++] = chr2;\n            }\n            if (enc4 !== 64) {\n                output[resultIndex++] = chr3;\n            }\n        }\n        return output;\n    };\n\n    return {\n        encode,\n        decode\n    }\n});\ndefine('skylark-jszip/external',[],function () {\n    'use strict';\n\n    return  { Promise};\n});\ndefine('skylark-jszip/utils',[\n    'skylark-langx-binary/buffer',\n    './support',\n    './base64',\n    './external',\n], function (Buffer,support, base64, external) {\n    'use strict';\n    var utils = {};\n\n    function string2binary(str) {\n        var result = null;\n        if (support.uint8array) {\n            result = new Uint8Array(str.length);\n        } else {\n            result = new Array(str.length);\n        }\n        return stringToArrayLike(str, result);\n    }\n    utils.newBlob = function (part, type) {\n        utils.checkSupport('blob');\n        try {\n            return new Blob([part], { type: type });\n        } catch (e) {\n            try {\n                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n                var builder = new Builder();\n                builder.append(part);\n                return builder.getBlob(type);\n            } catch (e) {\n                throw new Error(\"Bug : can't construct the Blob.\");\n            }\n        }\n    };\n    function identity(input) {\n        return input;\n    }\n    function stringToArrayLike(str, array) {\n        for (var i = 0; i < str.length; ++i) {\n            array[i] = str.charCodeAt(i) & 255;\n        }\n        return array;\n    }\n    var arrayToStringHelper = {\n        stringifyByChunk: function (array, type, chunk) {\n            var result = [], k = 0, len = array.length;\n            if (len <= chunk) {\n                return String.fromCharCode.apply(null, array);\n            }\n            while (k < len) {\n                if (type === 'array' || type === 'nodebuffer') {\n                    result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n                } else {\n                    result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n                }\n                k += chunk;\n            }\n            return result.join('');\n        },\n        stringifyByChar: function (array) {\n            var resultStr = '';\n            for (var i = 0; i < array.length; i++) {\n                resultStr += String.fromCharCode(array[i]);\n            }\n            return resultStr;\n        },\n        applyCanBeUsed: {\n            uint8array: function () {\n                try {\n                    return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n                } catch (e) {\n                    return false;\n                }\n            }(),\n            nodebuffer: function () {\n                try {\n                ///    return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n                    return support.nodebuffer && String.fromCharCode.apply(null, Buffer.alloc(1)).length === 1;\n                } catch (e) {\n                    return false;\n                }\n            }()\n        }\n    };\n    function arrayLikeToString(array) {\n        var chunk = 65536, type = utils.getTypeOf(array), canUseApply = true;\n        if (type === 'uint8array') {\n            canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n        } else if (type === 'nodebuffer') {\n            canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n        }\n        if (canUseApply) {\n            while (chunk > 1) {\n                try {\n                    return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n                } catch (e) {\n                    chunk = Math.floor(chunk / 2);\n                }\n            }\n        }\n        return arrayToStringHelper.stringifyByChar(array);\n    }\n    utils.applyFromCharCode = arrayLikeToString;\n    function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n        for (var i = 0; i < arrayFrom.length; i++) {\n            arrayTo[i] = arrayFrom[i];\n        }\n        return arrayTo;\n    }\n    var transform = {};\n    transform['string'] = {\n        'string': identity,\n        'array': function (input) {\n            return stringToArrayLike(input, new Array(input.length));\n        },\n        'arraybuffer': function (input) {\n            return transform['string']['uint8array'](input).buffer;\n        },\n        'uint8array': function (input) {\n            return stringToArrayLike(input, new Uint8Array(input.length));\n        },\n        'nodebuffer': function (input) {\n            ///return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n            return stringToArrayLike(input, Buffer.alloc(input.length));\n        }\n    };\n    transform['array'] = {\n        'string': arrayLikeToString,\n        'array': identity,\n        'arraybuffer': function (input) {\n            return new Uint8Array(input).buffer;\n        },\n        'uint8array': function (input) {\n            return new Uint8Array(input);\n        },\n        'nodebuffer': function (input) {\n            ///return nodejsUtils.newBufferFrom(input);\n            return Buffer.from(input);\n        }\n    };\n    transform['arraybuffer'] = {\n        'string': function (input) {\n            return arrayLikeToString(new Uint8Array(input));\n        },\n        'array': function (input) {\n            return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n        },\n        'arraybuffer': identity,\n        'uint8array': function (input) {\n            return new Uint8Array(input);\n        },\n        'nodebuffer': function (input) {\n            ///return nodejsUtils.newBufferFrom(new Uint8Array(input));\n            return Buffer.from(new Uint8Array(input));\n        }\n    };\n    transform['uint8array'] = {\n        'string': arrayLikeToString,\n        'array': function (input) {\n            return arrayLikeToArrayLike(input, new Array(input.length));\n        },\n        'arraybuffer': function (input) {\n            return input.buffer;\n        },\n        'uint8array': identity,\n        'nodebuffer': function (input) {\n            ///return nodejsUtils.newBufferFrom(input);\n            return Buffer.from(input);\n        }\n    };\n    transform['nodebuffer'] = {\n        'string': arrayLikeToString,\n        'array': function (input) {\n            return arrayLikeToArrayLike(input, new Array(input.length));\n        },\n        'arraybuffer': function (input) {\n            return transform['nodebuffer']['uint8array'](input).buffer;\n        },\n        'uint8array': function (input) {\n            return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n        },\n        'nodebuffer': identity\n    };\n    utils.transformTo = function (outputType, input) {\n        if (!input) {\n            input = '';\n        }\n        if (!outputType) {\n            return input;\n        }\n        utils.checkSupport(outputType);\n        var inputType = utils.getTypeOf(input);\n        var result = transform[inputType][outputType](input);\n        return result;\n    };\n    utils.resolve = function (path) {\n        var parts = path.split('/');\n        var result = [];\n        for (var index = 0; index < parts.length; index++) {\n            var part = parts[index];\n            if (part === '.' || part === '' && index !== 0 && index !== parts.length - 1) {\n                continue;\n            } else if (part === '..') {\n                result.pop();\n            } else {\n                result.push(part);\n            }\n        }\n        return result.join('/');\n    };\n    /*\n    utils.getTypeOf = function (input) {\n        if (typeof input === 'string') {\n            return 'string';\n        }\n        if (Object.prototype.toString.call(input) === '[object Array]') {\n            return 'array';\n        }\n        if (support.nodebuffer && Buffer.isBuffer(input)) {\n            return 'nodebuffer';\n        }\n        if (support.uint8array && input instanceof Uint8Array) {\n            return 'uint8array';\n        }\n        if (support.arraybuffer && input instanceof ArrayBuffer) {\n            return 'arraybuffer';\n        }\n    };\n    */\n    utils.getTypeOf = support.getTypeOf;\n    \n    utils.checkSupport = function (type) {\n        var supported = support[type.toLowerCase()];\n        if (!supported) {\n            throw new Error(type + ' is not supported by this platform');\n        }\n    };\n    utils.MAX_VALUE_16BITS = 65535;\n    utils.MAX_VALUE_32BITS = -1;\n    utils.pretty = function (str) {\n        var res = '', code, i;\n        for (i = 0; i < (str || '').length; i++) {\n            code = str.charCodeAt(i);\n            res += '\\\\x' + (code < 16 ? '0' : '') + code.toString(16).toUpperCase();\n        }\n        return res;\n    };\n    utils.delay = function (callback, args, self) {\n        setTimeout(function () {\n            callback.apply(self || null, args || []);\n        });\n    };\n    utils.inherits = function (ctor, superCtor) {\n        var Obj = function () {\n        };\n        Obj.prototype = superCtor.prototype;\n        ctor.prototype = new Obj();\n    };\n    utils.extend = function () {\n        var result = {}, i, attr;\n        for (i = 0; i < arguments.length; i++) {\n            for (attr in arguments[i]) {\n                if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === 'undefined') {\n                    result[attr] = arguments[i][attr];\n                }\n            }\n        }\n        return result;\n    };\n    utils.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n        var promise = external.Promise.resolve(inputData).then(function (data) {\n            var isBlob = support.blob && (data instanceof Blob || [\n                '[object File]',\n                '[object Blob]'\n            ].indexOf(Object.prototype.toString.call(data)) !== -1);\n            if (isBlob && typeof FileReader !== 'undefined') {\n                return new external.Promise(function (resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function (e) {\n                        resolve(e.target.result);\n                    };\n                    reader.onerror = function (e) {\n                        reject(e.target.error);\n                    };\n                    reader.readAsArrayBuffer(data);\n                });\n            } else {\n                return data;\n            }\n        });\n        return promise.then(function (data) {\n            var dataType = utils.getTypeOf(data);\n            if (!dataType) {\n                return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + 'in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?'));\n            }\n            if (dataType === 'arraybuffer') {\n                data = utils.transformTo('uint8array', data);\n            } else if (dataType === 'string') {\n                if (isBase64) {\n                    data = base64.decode(data);\n                } else if (isBinary) {\n                    if (isOptimizedBinaryString !== true) {\n                        data = string2binary(data);\n                    }\n                }\n            }\n            return data;\n        });\n    };\n\n    return utils;\n});\ndefine('skylark-jszip/stream/GenericWorker',[], function () {\n    'use strict';\n\n    function GenericWorker(name) {\n        this.name = name || 'default';\n        this.streamInfo = {};\n        this.generatedError = null;\n        this.extraStreamInfo = {};\n        this.isPaused = true;\n        this.isFinished = false;\n        this.isLocked = false;\n        this._listeners = {\n            'data': [],\n            'end': [],\n            'error': []\n        };\n        this.previous = null;\n    }\n    GenericWorker.prototype = {\n        push: function (chunk) {\n            this.emit('data', chunk);\n        },\n        end: function () {\n            if (this.isFinished) {\n                return false;\n            }\n            this.flush();\n            try {\n                this.emit('end');\n                this.cleanUp();\n                this.isFinished = true;\n            } catch (e) {\n                this.emit('error', e);\n            }\n            return true;\n        },\n        error: function (e) {\n            if (this.isFinished) {\n                return false;\n            }\n            if (this.isPaused) {\n                this.generatedError = e;\n            } else {\n                this.isFinished = true;\n                this.emit('error', e);\n                if (this.previous) {\n                    this.previous.error(e);\n                }\n                this.cleanUp();\n            }\n            return true;\n        },\n        on: function (name, listener) {\n            this._listeners[name].push(listener);\n            return this;\n        },\n        cleanUp: function () {\n            this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n            this._listeners = [];\n        },\n        emit: function (name, arg) {\n            if (this._listeners[name]) {\n                for (var i = 0; i < this._listeners[name].length; i++) {\n                    this._listeners[name][i].call(this, arg);\n                }\n            }\n        },\n        pipe: function (next) {\n            return next.registerPrevious(this);\n        },\n        registerPrevious: function (previous) {\n            if (this.isLocked) {\n                throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            }\n            this.streamInfo = previous.streamInfo;\n            this.mergeStreamInfo();\n            this.previous = previous;\n            var self = this;\n            previous.on('data', function (chunk) {\n                self.processChunk(chunk);\n            });\n            previous.on('end', function () {\n                self.end();\n            });\n            previous.on('error', function (e) {\n                self.error(e);\n            });\n            return this;\n        },\n        pause: function () {\n            if (this.isPaused || this.isFinished) {\n                return false;\n            }\n            this.isPaused = true;\n            if (this.previous) {\n                this.previous.pause();\n            }\n            return true;\n        },\n        resume: function () {\n            if (!this.isPaused || this.isFinished) {\n                return false;\n            }\n            this.isPaused = false;\n            var withError = false;\n            if (this.generatedError) {\n                this.error(this.generatedError);\n                withError = true;\n            }\n            if (this.previous) {\n                this.previous.resume();\n            }\n            return !withError;\n        },\n        flush: function () {\n        },\n        processChunk: function (chunk) {\n            this.push(chunk);\n        },\n        withStreamInfo: function (key, value) {\n            this.extraStreamInfo[key] = value;\n            this.mergeStreamInfo();\n            return this;\n        },\n        mergeStreamInfo: function () {\n            for (var key in this.extraStreamInfo) {\n                if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {\n                    continue;\n                }\n                this.streamInfo[key] = this.extraStreamInfo[key];\n            }\n        },\n        lock: function () {\n            if (this.isLocked) {\n                throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            }\n            this.isLocked = true;\n            if (this.previous) {\n                this.previous.lock();\n            }\n        },\n        toString: function () {\n            var me = 'Worker ' + this.name;\n            if (this.previous) {\n                return this.previous + ' -> ' + me;\n            } else {\n                return me;\n            }\n        }\n    };\n\n    return GenericWorker;\n\n});\ndefine('skylark-jszip/utf8',[\n    'skylark-langx-binary/buffer',\n    './utils',\n    './support',\n    './stream/GenericWorker'\n], function (Buffer,utils, support,  GenericWorker) {\n    'use strict';\n    var utf8 = {};\n\n    var _utf8len = new Array(256);\n    for (var i = 0; i < 256; i++) {\n        _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n    }\n    _utf8len[254] = _utf8len[254] = 1;\n    var string2buf = function (str) {\n        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n        for (m_pos = 0; m_pos < str_len; m_pos++) {\n            c = str.charCodeAt(m_pos);\n            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n                c2 = str.charCodeAt(m_pos + 1);\n                if ((c2 & 64512) === 56320) {\n                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n                    m_pos++;\n                }\n            }\n            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;\n        }\n        if (support.uint8array) {\n            buf = new Uint8Array(buf_len);\n        } else {\n            buf = new Array(buf_len);\n        }\n        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n            c = str.charCodeAt(m_pos);\n            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n                c2 = str.charCodeAt(m_pos + 1);\n                if ((c2 & 64512) === 56320) {\n                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n                    m_pos++;\n                }\n            }\n            if (c < 128) {\n                buf[i++] = c;\n            } else if (c < 2048) {\n                buf[i++] = 192 | c >>> 6;\n                buf[i++] = 128 | c & 63;\n            } else if (c < 65536) {\n                buf[i++] = 224 | c >>> 12;\n                buf[i++] = 128 | c >>> 6 & 63;\n                buf[i++] = 128 | c & 63;\n            } else {\n                buf[i++] = 240 | c >>> 18;\n                buf[i++] = 128 | c >>> 12 & 63;\n                buf[i++] = 128 | c >>> 6 & 63;\n                buf[i++] = 128 | c & 63;\n            }\n        }\n        return buf;\n    };\n    var utf8border = function (buf, max) {\n        var pos;\n        max = max || buf.length;\n        if (max > buf.length) {\n            max = buf.length;\n        }\n        pos = max - 1;\n        while (pos >= 0 && (buf[pos] & 192) === 128) {\n            pos--;\n        }\n        if (pos < 0) {\n            return max;\n        }\n        if (pos === 0) {\n            return max;\n        }\n        return pos + _utf8len[buf[pos]] > max ? pos : max;\n    };\n    var buf2string = function (buf) {\n        var i, out, c, c_len;\n        var len = buf.length;\n        var utf16buf = new Array(len * 2);\n        for (out = 0, i = 0; i < len;) {\n            c = buf[i++];\n            if (c < 128) {\n                utf16buf[out++] = c;\n                continue;\n            }\n            c_len = _utf8len[c];\n            if (c_len > 4) {\n                utf16buf[out++] = 65533;\n                i += c_len - 1;\n                continue;\n            }\n            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n            while (c_len > 1 && i < len) {\n                c = c << 6 | buf[i++] & 63;\n                c_len--;\n            }\n            if (c_len > 1) {\n                utf16buf[out++] = 65533;\n                continue;\n            }\n            if (c < 65536) {\n                utf16buf[out++] = c;\n            } else {\n                c -= 65536;\n                utf16buf[out++] = 55296 | c >> 10 & 1023;\n                utf16buf[out++] = 56320 | c & 1023;\n            }\n        }\n        if (utf16buf.length !== out) {\n            if (utf16buf.subarray) {\n                utf16buf = utf16buf.subarray(0, out);\n            } else {\n                utf16buf.length = out;\n            }\n        }\n        return utils.applyFromCharCode(utf16buf);\n    };\n    utf8.utf8encode = function utf8encode(str) {\n        if (support.nodebuffer) {\n            ///return nodejsUtils.newBufferFrom(str, 'utf-8');\n            return Buffer.from(str,'utf-8');\n        }\n        return string2buf(str);\n    };\n    utf8.utf8decode = function utf8decode(buf) {\n        if (support.nodebuffer) {\n            return utils.transformTo('nodebuffer', buf).toString('utf-8');\n        }\n        buf = utils.transformTo(support.uint8array ? 'uint8array' : 'array', buf);\n        return buf2string(buf);\n    };\n    function Utf8DecodeWorker() {\n        GenericWorker.call(this, 'utf-8 decode');\n        this.leftOver = null;\n    }\n    utils.inherits(Utf8DecodeWorker, GenericWorker);\n    Utf8DecodeWorker.prototype.processChunk = function (chunk) {\n        var data = utils.transformTo(support.uint8array ? 'uint8array' : 'array', chunk.data);\n        if (this.leftOver && this.leftOver.length) {\n            if (support.uint8array) {\n                var previousData = data;\n                data = new Uint8Array(previousData.length + this.leftOver.length);\n                data.set(this.leftOver, 0);\n                data.set(previousData, this.leftOver.length);\n            } else {\n                data = this.leftOver.concat(data);\n            }\n            this.leftOver = null;\n        }\n        var nextBoundary = utf8border(data);\n        var usableData = data;\n        if (nextBoundary !== data.length) {\n            if (support.uint8array) {\n                usableData = data.subarray(0, nextBoundary);\n                this.leftOver = data.subarray(nextBoundary, data.length);\n            } else {\n                usableData = data.slice(0, nextBoundary);\n                this.leftOver = data.slice(nextBoundary, data.length);\n            }\n        }\n        this.push({\n            data: utf8.utf8decode(usableData),\n            meta: chunk.meta\n        });\n    };\n    Utf8DecodeWorker.prototype.flush = function () {\n        if (this.leftOver && this.leftOver.length) {\n            this.push({\n                data: utf8.utf8decode(this.leftOver),\n                meta: {}\n            });\n            this.leftOver = null;\n        }\n    };\n    utf8.Utf8DecodeWorker = Utf8DecodeWorker;\n    function Utf8EncodeWorker() {\n        GenericWorker.call(this, 'utf-8 encode');\n    }\n    utils.inherits(Utf8EncodeWorker, GenericWorker);\n    Utf8EncodeWorker.prototype.processChunk = function (chunk) {\n        this.push({\n            data: utf8.utf8encode(chunk.data),\n            meta: chunk.meta\n        });\n    };\n    utf8.Utf8EncodeWorker = Utf8EncodeWorker;\n\n    return utf8;\n});\ndefine('skylark-jszip/stream/ConvertWorker',[\n    './GenericWorker',\n    '../utils'\n], function (GenericWorker, utils) {\n    'use strict';\n\n    function ConvertWorker(destType) {\n        GenericWorker.call(this, 'ConvertWorker to ' + destType);\n        this.destType = destType;\n    }\n    utils.inherits(ConvertWorker, GenericWorker);\n    ConvertWorker.prototype.processChunk = function (chunk) {\n        this.push({\n            data: utils.transformTo(this.destType, chunk.data),\n            meta: chunk.meta\n        });\n    };\n\n    return ConvertWorker;\n\n});\ndefine('skylark-jszip/stream/StreamHelper',[\n    '../utils',\n    './ConvertWorker',\n    './GenericWorker',\n    '../base64',\n    '../support',\n    '../external'\n], function (utils, ConvertWorker, GenericWorker, base64, support, external) {\n    'use strict';\n\n    ///if (support.nodestream) {\n    ///    try {\n    ///        NodejsStreamOutputAdapter = __module__6;\n    ///    } catch (e) {\n    ///    }\n    ///}\n    function transformZipOutput(type, content, mimeType) {\n        switch (type) {\n        case 'blob':\n            return utils.newBlob(utils.transformTo('arraybuffer', content), mimeType);\n        case 'base64':\n            return base64.encode(content);\n        default:\n            return utils.transformTo(type, content);\n        }\n    }\n    function concat(type, dataArray) {\n        var i, index = 0, res = null, totalLength = 0;\n        for (i = 0; i < dataArray.length; i++) {\n            totalLength += dataArray[i].length;\n        }\n        switch (type) {\n        case 'string':\n            return dataArray.join('');\n        case 'array':\n            return Array.prototype.concat.apply([], dataArray);\n        case 'uint8array':\n            res = new Uint8Array(totalLength);\n            for (i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case 'nodebuffer':\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\" + type + \"'\");\n        }\n    }\n    function accumulate(helper, updateCallback) {\n        return new external.Promise(function (resolve, reject) {\n            var dataArray = [];\n            var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;\n            helper.on('data', function (data, meta) {\n                dataArray.push(data);\n                if (updateCallback) {\n                    updateCallback(meta);\n                }\n            }).on('error', function (err) {\n                dataArray = [];\n                reject(err);\n            }).on('end', function () {\n                try {\n                    var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n                dataArray = [];\n            }).resume();\n        });\n    }\n    function StreamHelper(worker, outputType, mimeType) {\n        var internalType = outputType;\n        switch (outputType) {\n        case 'blob':\n        case 'arraybuffer':\n            internalType = 'uint8array';\n            break;\n        case 'base64':\n            internalType = 'string';\n            break;\n        }\n        try {\n            this._internalType = internalType;\n            this._outputType = outputType;\n            this._mimeType = mimeType;\n            utils.checkSupport(internalType);\n            this._worker = worker.pipe(new ConvertWorker(internalType));\n            worker.lock();\n        } catch (e) {\n            this._worker = new GenericWorker('error');\n            this._worker.error(e);\n        }\n    }\n    StreamHelper.prototype = {\n        accumulate: function (updateCb) {\n            return accumulate(this, updateCb);\n        },\n        on: function (evt, fn) {\n            var self = this;\n            if (evt === 'data') {\n                this._worker.on(evt, function (chunk) {\n                    fn.call(self, chunk.data, chunk.meta);\n                });\n            } else {\n                this._worker.on(evt, function () {\n                    utils.delay(fn, arguments, self);\n                });\n            }\n            return this;\n        },\n        resume: function () {\n            utils.delay(this._worker.resume, [], this._worker);\n            return this;\n        },\n        pause: function () {\n            this._worker.pause();\n            return this;\n        },\n        toNodejsStream: function (updateCb) {\n            utils.checkSupport('nodestream');\n            if (this._outputType !== 'nodebuffer') {\n                throw new Error(this._outputType + ' is not supported by this method');\n            }\n            return new NodejsStreamOutputAdapter(this, { objectMode: this._outputType !== 'nodebuffer' }, updateCb);\n        }\n    };\n   \n    return StreamHelper;\n});\ndefine('skylark-jszip/defaults',[], function () {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    exports.base64 = false;\n    exports.binary = false;\n    exports.dir = false;\n    exports.createFolders = true;\n    exports.date = null;\n    exports.compression = null;\n    exports.compressionOptions = null;\n    exports.comment = null;\n    exports.unixPermissions = null;\n    exports.dosPermissions = null;\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine('skylark-jszip/stream/DataWorker',[\n    '../utils',\n    './GenericWorker'\n], function (utils, GenericWorker) {\n    'use strict';\n\n    var DEFAULT_BLOCK_SIZE = 16 * 1024;\n    function DataWorker(dataP) {\n        GenericWorker.call(this, 'DataWorker');\n        var self = this;\n        this.dataIsReady = false;\n        this.index = 0;\n        this.max = 0;\n        this.data = null;\n        this.type = '';\n        this._tickScheduled = false;\n        dataP.then(function (data) {\n            self.dataIsReady = true;\n            self.data = data;\n            self.max = data && data.length || 0;\n            self.type = utils.getTypeOf(data);\n            if (!self.isPaused) {\n                self._tickAndRepeat();\n            }\n        }, function (e) {\n            self.error(e);\n        });\n    }\n    utils.inherits(DataWorker, GenericWorker);\n    DataWorker.prototype.cleanUp = function () {\n        GenericWorker.prototype.cleanUp.call(this);\n        this.data = null;\n    };\n    DataWorker.prototype.resume = function () {\n        if (!GenericWorker.prototype.resume.call(this)) {\n            return false;\n        }\n        if (!this._tickScheduled && this.dataIsReady) {\n            this._tickScheduled = true;\n            utils.delay(this._tickAndRepeat, [], this);\n        }\n        return true;\n    };\n    DataWorker.prototype._tickAndRepeat = function () {\n        this._tickScheduled = false;\n        if (this.isPaused || this.isFinished) {\n            return;\n        }\n        this._tick();\n        if (!this.isFinished) {\n            utils.delay(this._tickAndRepeat, [], this);\n            this._tickScheduled = true;\n        }\n    };\n    DataWorker.prototype._tick = function () {\n        if (this.isPaused || this.isFinished) {\n            return false;\n        }\n        var size = DEFAULT_BLOCK_SIZE;\n        var data = null, nextIndex = Math.min(this.max, this.index + size);\n        if (this.index >= this.max) {\n            return this.end();\n        } else {\n            switch (this.type) {\n            case 'string':\n                data = this.data.substring(this.index, nextIndex);\n                break;\n            case 'uint8array':\n                data = this.data.subarray(this.index, nextIndex);\n                break;\n            case 'array':\n            case 'nodebuffer':\n                data = this.data.slice(this.index, nextIndex);\n                break;\n            }\n            this.index = nextIndex;\n            return this.push({\n                data: data,\n                meta: { percent: this.max ? this.index / this.max * 100 : 0 }\n            });\n        }\n    };\n    \n    return DataWorker;\n});\ndefine('skylark-jszip/crc32',['./utils'], function (utils) {\n    'use strict';\n\n    function makeTable() {\n        var c, table = [];\n        for (var n = 0; n < 256; n++) {\n            c = n;\n            for (var k = 0; k < 8; k++) {\n                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n            }\n            table[n] = c;\n        }\n        return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n        var t = crcTable, end = pos + len;\n        crc = crc ^ -1;\n        for (var i = pos; i < end; i++) {\n            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n        }\n        return crc ^ -1;\n    }\n    function crc32str(crc, str, len, pos) {\n        var t = crcTable, end = pos + len;\n        crc = crc ^ -1;\n        for (var i = pos; i < end; i++) {\n            crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];\n        }\n        return crc ^ -1;\n    }\n    function crc32wrapper(input, crc) {\n        if (typeof input === 'undefined' || !input.length) {\n            return 0;\n        }\n        var isArray = utils.getTypeOf(input) !== 'string';\n        if (isArray) {\n            return crc32(crc | 0, input, input.length, 0);\n        } else {\n            return crc32str(crc | 0, input, input.length, 0);\n        }\n    }\n\n    return crc32wrapper;\n});\ndefine('skylark-jszip/stream/Crc32Probe',[\n    './GenericWorker',\n    '../crc32',\n    '../utils'\n], function (GenericWorker, crc32, utils) {\n    'use strict';\n\n    function Crc32Probe() {\n        GenericWorker.call(this, 'Crc32Probe');\n        this.withStreamInfo('crc32', 0);\n    }\n    utils.inherits(Crc32Probe, GenericWorker);\n    Crc32Probe.prototype.processChunk = function (chunk) {\n        this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n        this.push(chunk);\n    };\n    \n    return Crc32Probe;\n\n});\ndefine('skylark-jszip/stream/DataLengthProbe',[\n    '../utils',\n    './GenericWorker'\n], function (utils, GenericWorker) {\n    'use strict';\n\n    function DataLengthProbe(propName) {\n        GenericWorker.call(this, 'DataLengthProbe for ' + propName);\n        this.propName = propName;\n        this.withStreamInfo(propName, 0);\n    }\n    utils.inherits(DataLengthProbe, GenericWorker);\n    DataLengthProbe.prototype.processChunk = function (chunk) {\n        if (chunk) {\n            var length = this.streamInfo[this.propName] || 0;\n            this.streamInfo[this.propName] = length + chunk.data.length;\n        }\n        GenericWorker.prototype.processChunk.call(this, chunk);\n    };\n    return DataLengthProbe;\n\n});\ndefine('skylark-jszip/compressedObject',[\n    './external',\n    './stream/DataWorker',\n    './stream/Crc32Probe',\n    './stream/DataLengthProbe'\n], function (external, DataWorker, Crc32Probe, DataLengthProbe) {\n    'use strict';\n\n    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n        this.compressedSize = compressedSize;\n        this.uncompressedSize = uncompressedSize;\n        this.crc32 = crc32;\n        this.compression = compression;\n        this.compressedContent = data;\n    }\n    CompressedObject.prototype = {\n        getContentWorker: function () {\n            var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe('data_length'));\n            var that = this;\n            worker.on('end', function () {\n                if (this.streamInfo['data_length'] !== that.uncompressedSize) {\n                    throw new Error('Bug : uncompressed data size mismatch');\n                }\n            });\n            return worker;\n        },\n        getCompressedWorker: function () {\n            return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo('compressedSize', this.compressedSize).withStreamInfo('uncompressedSize', this.uncompressedSize).withStreamInfo('crc32', this.crc32).withStreamInfo('compression', this.compression);\n        }\n    };\n    CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n        return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe('uncompressedSize')).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe('compressedSize')).withStreamInfo('compression', compression);\n    };\n    \n    return CompressedObject;\n\n});\ndefine('skylark-jszip/zipObject',[\n    './stream/StreamHelper',\n    './stream/DataWorker',\n    './utf8',\n    './compressedObject',\n    './stream/GenericWorker'\n], function (StreamHelper, DataWorker, utf8, CompressedObject, GenericWorker) {\n    'use strict';\n\n    var ZipObject = function (name, data, options) {\n        this.name = name;\n        this.dir = options.dir;\n        this.date = options.date;\n        this.comment = options.comment;\n        this.unixPermissions = options.unixPermissions;\n        this.dosPermissions = options.dosPermissions;\n        this._data = data;\n        this._dataBinary = options.binary;\n        this.options = {\n            compression: options.compression,\n            compressionOptions: options.compressionOptions\n        };\n    };\n    ZipObject.prototype = {\n        internalStream: function (type) {\n            var result = null, outputType = 'string';\n            try {\n                if (!type) {\n                    throw new Error('No output type specified.');\n                }\n                outputType = type.toLowerCase();\n                var askUnicodeString = outputType === 'string' || outputType === 'text';\n                if (outputType === 'binarystring' || outputType === 'text') {\n                    outputType = 'string';\n                }\n                result = this._decompressWorker();\n                var isUnicodeString = !this._dataBinary;\n                if (isUnicodeString && !askUnicodeString) {\n                    result = result.pipe(new utf8.Utf8EncodeWorker());\n                }\n                if (!isUnicodeString && askUnicodeString) {\n                    result = result.pipe(new utf8.Utf8DecodeWorker());\n                }\n            } catch (e) {\n                result = new GenericWorker('error');\n                result.error(e);\n            }\n            return new StreamHelper(result, outputType, '');\n        },\n        async: function (type, onUpdate) {\n            return this.internalStream(type).accumulate(onUpdate);\n        },\n        nodeStream: function (type, onUpdate) {\n            return this.internalStream(type || 'nodebuffer').toNodejsStream(onUpdate);\n        },\n        _compressWorker: function (compression, compressionOptions) {\n            if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n                return this._data.getCompressedWorker();\n            } else {\n                var result = this._decompressWorker();\n                if (!this._dataBinary) {\n                    result = result.pipe(new utf8.Utf8EncodeWorker());\n                }\n                return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n            }\n        },\n        _decompressWorker: function () {\n            if (this._data instanceof CompressedObject) {\n                return this._data.getContentWorker();\n            } else if (this._data instanceof GenericWorker) {\n                return this._data;\n            } else {\n                return new DataWorker(this._data);\n            }\n        }\n    };\n    var removedMethods = [\n        'asText',\n        'asBinary',\n        'asNodeBuffer',\n        'asUint8Array',\n        'asArrayBuffer'\n    ];\n    var removedFn = function () {\n        throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.');\n    };\n    for (var i = 0; i < removedMethods.length; i++) {\n        ZipObject.prototype[removedMethods[i]] = removedFn;\n    }\n    return ZipObject;\n\n});\ndefine('skylark-jszip/flate',[\n    'skylark-pako',\n    './utils',\n    './stream/GenericWorker'\n], function (pako, utils, GenericWorker) {\n    'use strict';\n\n    var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';\n\n    var ARRAY_TYPE = USE_TYPEDARRAY ? 'uint8array' : 'array';\n\n    var flate = {};\n\n    flate.magic = '\\b\\0';\n\n    function FlateWorker(action, options) {\n        GenericWorker.call(this, 'FlateWorker/' + action);\n        this._pako = null;\n        this._pakoAction = action;\n        this._pakoOptions = options;\n        this.meta = {};\n    }\n\n    utils.inherits(FlateWorker, GenericWorker);\n\n    FlateWorker.prototype.processChunk = function (chunk) {\n        this.meta = chunk.meta;\n        if (this._pako === null) {\n            this._createPako();\n        }\n        this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n    };\n    FlateWorker.prototype.flush = function () {\n        GenericWorker.prototype.flush.call(this);\n        if (this._pako === null) {\n            this._createPako();\n        }\n        this._pako.push([], true);\n    };\n    FlateWorker.prototype.cleanUp = function () {\n        GenericWorker.prototype.cleanUp.call(this);\n        this._pako = null;\n    };\n    FlateWorker.prototype._createPako = function () {\n        this._pako = new pako[this._pakoAction]({\n            raw: true,\n            level: this._pakoOptions.level || -1\n        });\n        var self = this;\n        this._pako.onData = function (data) {\n            self.push({\n                data: data,\n                meta: self.meta\n            });\n        };\n    };\n\n    flate.compressWorker = function (compressionOptions) {\n        return new FlateWorker(\"Deflate\", compressionOptions);\n    };\n    flate.uncompressWorker = function () {\n        return new FlateWorker(\"Inflate\", {});\n    };\n\n    return flate;\n});\ndefine('skylark-jszip/compressions',[\n    './stream/GenericWorker',\n    './flate'\n], function (GenericWorker, DEFLATE) {\n    'use strict';\n\n    var STORE = {\n        magic: '\\0\\0',\n        compressWorker: function () {\n            return new GenericWorker('STORE compression');\n        },\n        uncompressWorker: function () {\n            return new GenericWorker('STORE decompression');\n        }\n    };\n\n    return {\n        STORE,\n        DEFLATE\n    }\n});\ndefine('skylark-jszip/signature',[], function () {\n    'use strict';\n\n    const LOCAL_FILE_HEADER = 'PK\\x03\\x04';\n    const CENTRAL_FILE_HEADER = 'PK\\x01\\x02';\n    const CENTRAL_DIRECTORY_END = 'PK\\x05\\x06';\n    const ZIP64_CENTRAL_DIRECTORY_LOCATOR = 'PK\\x06\\x07';\n    const ZIP64_CENTRAL_DIRECTORY_END = 'PK\\x06\\x06';\n    const DATA_DESCRIPTOR = 'PK\\x07\\b';\n\n    return {\n        LOCAL_FILE_HEADER,\n        CENTRAL_FILE_HEADER,\n        CENTRAL_DIRECTORY_END,\n        ZIP64_CENTRAL_DIRECTORY_LOCATOR,\n        ZIP64_CENTRAL_DIRECTORY_END,\n        DATA_DESCRIPTOR\n    };\n});\ndefine('skylark-jszip/generate/ZipFileWorker',[\n    '../utils',\n    '../stream/GenericWorker',\n    '../utf8',\n    '../crc32',\n    '../signature'\n], function (utils, GenericWorker, utf8, crc32, signature) {\n    'use strict';\n\n    var decToHex = function (dec, bytes) {\n        var hex = '', i;\n        for (i = 0; i < bytes; i++) {\n            hex += String.fromCharCode(dec & 255);\n            dec = dec >>> 8;\n        }\n        return hex;\n    };\n    var generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n        var result = unixPermissions;\n        if (!unixPermissions) {\n            result = isDir ? 16893 : 33204;\n        }\n        return (result & 65535) << 16;\n    };\n    var generateDosExternalFileAttr = function (dosPermissions) {\n        return (dosPermissions || 0) & 63;\n    };\n    var generateZipParts = function (streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n        var file = streamInfo['file'], compression = streamInfo['compression'], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo('string', encodeFileName(file.name)), utfEncodedFileName = utils.transformTo('string', utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo('string', encodeFileName(comment)), utfEncodedComment = utils.transformTo('string', utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = '', unicodePathExtraField = '', unicodeCommentExtraField = '', dir = file.dir, date = file.date;\n        var dataInfo = {\n            crc32: 0,\n            compressedSize: 0,\n            uncompressedSize: 0\n        };\n        if (!streamedContent || streamingEnded) {\n            dataInfo.crc32 = streamInfo['crc32'];\n            dataInfo.compressedSize = streamInfo['compressedSize'];\n            dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n        }\n        var bitflag = 0;\n        if (streamedContent) {\n            bitflag |= 8;\n        }\n        if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n            bitflag |= 2048;\n        }\n        var extFileAttr = 0;\n        var versionMadeBy = 0;\n        if (dir) {\n            extFileAttr |= 16;\n        }\n        if (platform === 'UNIX') {\n            versionMadeBy = 798;\n            extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n        } else {\n            versionMadeBy = 20;\n            extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n        }\n        dosTime = date.getUTCHours();\n        dosTime = dosTime << 6;\n        dosTime = dosTime | date.getUTCMinutes();\n        dosTime = dosTime << 5;\n        dosTime = dosTime | date.getUTCSeconds() / 2;\n        dosDate = date.getUTCFullYear() - 1980;\n        dosDate = dosDate << 4;\n        dosDate = dosDate | date.getUTCMonth() + 1;\n        dosDate = dosDate << 5;\n        dosDate = dosDate | date.getUTCDate();\n        if (useUTF8ForFileName) {\n            unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;\n            extraFields += 'up' + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;\n        }\n        if (useUTF8ForComment) {\n            unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;\n            extraFields += 'uc' + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;\n        }\n        var header = '';\n        header += '\\n\\0';\n        header += decToHex(bitflag, 2);\n        header += compression.magic;\n        header += decToHex(dosTime, 2);\n        header += decToHex(dosDate, 2);\n        header += decToHex(dataInfo.crc32, 4);\n        header += decToHex(dataInfo.compressedSize, 4);\n        header += decToHex(dataInfo.uncompressedSize, 4);\n        header += decToHex(encodedFileName.length, 2);\n        header += decToHex(extraFields.length, 2);\n        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n        var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + '\\0\\0' + '\\0\\0' + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;\n        return {\n            fileRecord: fileRecord,\n            dirRecord: dirRecord\n        };\n    };\n    var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n        var dirEnd = '';\n        var encodedComment = utils.transformTo('string', encodeFileName(comment));\n        dirEnd = signature.CENTRAL_DIRECTORY_END + '\\0\\0' + '\\0\\0' + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;\n        return dirEnd;\n    };\n    var generateDataDescriptors = function (streamInfo) {\n        var descriptor = '';\n        descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo['crc32'], 4) + decToHex(streamInfo['compressedSize'], 4) + decToHex(streamInfo['uncompressedSize'], 4);\n        return descriptor;\n    };\n    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n        GenericWorker.call(this, 'ZipFileWorker');\n        this.bytesWritten = 0;\n        this.zipComment = comment;\n        this.zipPlatform = platform;\n        this.encodeFileName = encodeFileName;\n        this.streamFiles = streamFiles;\n        this.accumulate = false;\n        this.contentBuffer = [];\n        this.dirRecords = [];\n        this.currentSourceOffset = 0;\n        this.entriesCount = 0;\n        this.currentFile = null;\n        this._sources = [];\n    }\n    utils.inherits(ZipFileWorker, GenericWorker);\n    ZipFileWorker.prototype.push = function (chunk) {\n        var currentFilePercent = chunk.meta.percent || 0;\n        var entriesCount = this.entriesCount;\n        var remainingFiles = this._sources.length;\n        if (this.accumulate) {\n            this.contentBuffer.push(chunk);\n        } else {\n            this.bytesWritten += chunk.data.length;\n            GenericWorker.prototype.push.call(this, {\n                data: chunk.data,\n                meta: {\n                    currentFile: this.currentFile,\n                    percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n                }\n            });\n        }\n    };\n    ZipFileWorker.prototype.openedSource = function (streamInfo) {\n        this.currentSourceOffset = this.bytesWritten;\n        this.currentFile = streamInfo['file'].name;\n        var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n        if (streamedContent) {\n            var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n            this.push({\n                data: record.fileRecord,\n                meta: { percent: 0 }\n            });\n        } else {\n            this.accumulate = true;\n        }\n    };\n    ZipFileWorker.prototype.closedSource = function (streamInfo) {\n        this.accumulate = false;\n        var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n        var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.dirRecords.push(record.dirRecord);\n        if (streamedContent) {\n            this.push({\n                data: generateDataDescriptors(streamInfo),\n                meta: { percent: 100 }\n            });\n        } else {\n            this.push({\n                data: record.fileRecord,\n                meta: { percent: 0 }\n            });\n            while (this.contentBuffer.length) {\n                this.push(this.contentBuffer.shift());\n            }\n        }\n        this.currentFile = null;\n    };\n    ZipFileWorker.prototype.flush = function () {\n        var localDirLength = this.bytesWritten;\n        for (var i = 0; i < this.dirRecords.length; i++) {\n            this.push({\n                data: this.dirRecords[i],\n                meta: { percent: 100 }\n            });\n        }\n        var centralDirLength = this.bytesWritten - localDirLength;\n        var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n        this.push({\n            data: dirEnd,\n            meta: { percent: 100 }\n        });\n    };\n    ZipFileWorker.prototype.prepareNextSource = function () {\n        this.previous = this._sources.shift();\n        this.openedSource(this.previous.streamInfo);\n        if (this.isPaused) {\n            this.previous.pause();\n        } else {\n            this.previous.resume();\n        }\n    };\n    ZipFileWorker.prototype.registerPrevious = function (previous) {\n        this._sources.push(previous);\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.closedSource(self.previous.streamInfo);\n            if (self._sources.length) {\n                self.prepareNextSource();\n            } else {\n                self.end();\n            }\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    };\n    ZipFileWorker.prototype.resume = function () {\n        if (!GenericWorker.prototype.resume.call(this)) {\n            return false;\n        }\n        if (!this.previous && this._sources.length) {\n            this.prepareNextSource();\n            return true;\n        }\n        if (!this.previous && !this._sources.length && !this.generatedError) {\n            this.end();\n            return true;\n        }\n    };\n    ZipFileWorker.prototype.error = function (e) {\n        var sources = this._sources;\n        if (!GenericWorker.prototype.error.call(this, e)) {\n            return false;\n        }\n        for (var i = 0; i < sources.length; i++) {\n            try {\n                sources[i].error(e);\n            } catch (e) {\n            }\n        }\n        return true;\n    };\n    ZipFileWorker.prototype.lock = function () {\n        GenericWorker.prototype.lock.call(this);\n        var sources = this._sources;\n        for (var i = 0; i < sources.length; i++) {\n            sources[i].lock();\n        }\n    };\n\n    return ZipFileWorker;\n\n});\ndefine('skylark-jszip/generate',[\r\n    './compressions',\r\n    './generate/ZipFileWorker'\r\n], function (compressions, ZipFileWorker) {\r\n    'use strict';\r\n\r\n    var getCompression = function (fileCompression, zipCompression) {\r\n        var compressionName = fileCompression || zipCompression;\r\n        var compression = compressions[compressionName];\r\n        if (!compression) {\r\n            throw new Error(compressionName + ' is not a valid compression method !');\r\n        }\r\n        return compression;\r\n    };\r\n    function generateWorker(zip, options, comment) {\r\n        var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\r\n        var entriesCount = 0;\r\n        try {\r\n            zip.forEach(function (relativePath, file) {\r\n                entriesCount++;\r\n                var compression = getCompression(file.options.compression, options.compression);\r\n                var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\r\n                var dir = file.dir, date = file.date;\r\n                file._compressWorker(compression, compressionOptions).withStreamInfo('file', {\r\n                    name: relativePath,\r\n                    dir: dir,\r\n                    date: date,\r\n                    comment: file.comment || '',\r\n                    unixPermissions: file.unixPermissions,\r\n                    dosPermissions: file.dosPermissions\r\n                }).pipe(zipFileWorker);\r\n            });\r\n            zipFileWorker.entriesCount = entriesCount;\r\n        } catch (e) {\r\n            zipFileWorker.error(e);\r\n        }\r\n        return zipFileWorker;\r\n    };\r\n\r\n    return generateWorker;\r\n\r\n});\ndefine('skylark-jszip/object',[\n    './utf8',\n    './utils',\n    './stream/GenericWorker',\n    './stream/StreamHelper',\n    './defaults',\n    './compressedObject',\n    './zipObject',\n    './generate'\n], function (utf8, utils, GenericWorker, StreamHelper, defaults, CompressedObject, ZipObject, generate) {\n    'use strict';\n\n    var fileAdd = function (name, data, originalOptions) {\n        var dataType = utils.getTypeOf(data), parent;\n        var o = utils.extend(originalOptions || {}, defaults);\n        o.date = o.date || new Date();\n        if (o.compression !== null) {\n            o.compression = o.compression.toUpperCase();\n        }\n        if (typeof o.unixPermissions === 'string') {\n            o.unixPermissions = parseInt(o.unixPermissions, 8);\n        }\n        if (o.unixPermissions && o.unixPermissions & 16384) {\n            o.dir = true;\n        }\n        if (o.dosPermissions && o.dosPermissions & 16) {\n            o.dir = true;\n        }\n        if (o.dir) {\n            name = forceTrailingSlash(name);\n        }\n        if (o.createFolders && (parent = parentFolder(name))) {\n            folderAdd.call(this, parent, true);\n        }\n        var isUnicodeString = dataType === 'string' && o.binary === false && o.base64 === false;\n        if (!originalOptions || typeof originalOptions.binary === 'undefined') {\n            o.binary = !isUnicodeString;\n        }\n        var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;\n        if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n            o.base64 = false;\n            o.binary = true;\n            data = '';\n            o.compression = 'STORE';\n            dataType = 'string';\n        }\n        var zipObjectContent = null;\n        if (data instanceof CompressedObject || data instanceof GenericWorker) {\n            zipObjectContent = data;\n        ///} else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        ///    zipObjectContent = new NodejsStreamInputAdapter(name, data);\n        } else {\n            zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n        }\n        var object = new ZipObject(name, zipObjectContent, o);\n        this.files[name] = object;\n    };\n    var parentFolder = function (path) {\n        if (path.slice(-1) === '/') {\n            path = path.substring(0, path.length - 1);\n        }\n        var lastSlash = path.lastIndexOf('/');\n        return lastSlash > 0 ? path.substring(0, lastSlash) : '';\n    };\n    var forceTrailingSlash = function (path) {\n        if (path.slice(-1) !== '/') {\n            path += '/';\n        }\n        return path;\n    };\n    var folderAdd = function (name, createFolders) {\n        createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;\n        name = forceTrailingSlash(name);\n        if (!this.files[name]) {\n            fileAdd.call(this, name, null, {\n                dir: true,\n                createFolders: createFolders\n            });\n        }\n        return this.files[name];\n    };\n    function isRegExp(object) {\n        return Object.prototype.toString.call(object) === '[object RegExp]';\n    }\n    var out = {\n        load: function () {\n            throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.');\n        },\n        forEach: function (cb) {\n            var filename, relativePath, file;\n            for (filename in this.files) {\n                file = this.files[filename];\n                relativePath = filename.slice(this.root.length, filename.length);\n                if (relativePath && filename.slice(0, this.root.length) === this.root) {\n                    cb(relativePath, file);\n                }\n            }\n        },\n        filter: function (search) {\n            var result = [];\n            this.forEach(function (relativePath, entry) {\n                if (search(relativePath, entry)) {\n                    result.push(entry);\n                }\n            });\n            return result;\n        },\n        file: function (name, data, o) {\n            if (arguments.length === 1) {\n                if (isRegExp(name)) {\n                    var regexp = name;\n                    return this.filter(function (relativePath, file) {\n                        return !file.dir && regexp.test(relativePath);\n                    });\n                } else {\n                    var obj = this.files[this.root + name];\n                    if (obj && !obj.dir) {\n                        return obj;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                name = this.root + name;\n                fileAdd.call(this, name, data, o);\n            }\n            return this;\n        },\n        folder: function (arg) {\n            if (!arg) {\n                return this;\n            }\n            if (isRegExp(arg)) {\n                return this.filter(function (relativePath, file) {\n                    return file.dir && arg.test(relativePath);\n                });\n            }\n            var name = this.root + arg;\n            var newFolder = folderAdd.call(this, name);\n            var ret = this.clone();\n            ret.root = newFolder.name;\n            return ret;\n        },\n        remove: function (name) {\n            name = this.root + name;\n            var file = this.files[name];\n            if (!file) {\n                if (name.slice(-1) !== '/') {\n                    name += '/';\n                }\n                file = this.files[name];\n            }\n            if (file && !file.dir) {\n                delete this.files[name];\n            } else {\n                var kids = this.filter(function (relativePath, file) {\n                    return file.name.slice(0, name.length) === name;\n                });\n                for (var i = 0; i < kids.length; i++) {\n                    delete this.files[kids[i].name];\n                }\n            }\n            return this;\n        },\n        generate: function () {\n            throw new Error('This method has been removed in JSZip 3.0, please check the upgrade guide.');\n        },\n        generateInternalStream: function (options) {\n            var worker, opts = {};\n            try {\n                opts = utils.extend(options || {}, {\n                    streamFiles: false,\n                    compression: 'STORE',\n                    compressionOptions: null,\n                    type: '',\n                    platform: 'DOS',\n                    comment: null,\n                    mimeType: 'application/zip',\n                    encodeFileName: utf8.utf8encode\n                });\n                opts.type = opts.type.toLowerCase();\n                opts.compression = opts.compression.toUpperCase();\n                if (opts.type === 'binarystring') {\n                    opts.type = 'string';\n                }\n                if (!opts.type) {\n                    throw new Error('No output type specified.');\n                }\n                utils.checkSupport(opts.type);\n                if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {\n                    opts.platform = 'UNIX';\n                }\n                if (opts.platform === 'win32') {\n                    opts.platform = 'DOS';\n                }\n                var comment = opts.comment || this.comment || '';\n                worker = generate.generateWorker(this, opts, comment);\n            } catch (e) {\n                worker = new GenericWorker('error');\n                worker.error(e);\n            }\n            return new StreamHelper(worker, opts.type || 'string', opts.mimeType);\n        },\n        generateAsync: function (options, onUpdate) {\n            return this.generateInternalStream(options).accumulate(onUpdate);\n        },\n        generateNodeStream: function (options, onUpdate) {\n            options = options || {};\n            if (!options.type) {\n                options.type = 'nodebuffer';\n            }\n            return this.generateInternalStream(options).toNodejsStream(onUpdate);\n        }\n    };\n\n    return out;\n\n});\ndefine('skylark-jszip/reader/DataReader',['../utils'], function (utils) {\n    'use strict';\n\n    function DataReader(data) {\n        this.data = data;\n        this.length = data.length;\n        this.index = 0;\n        this.zero = 0;\n    }\n    DataReader.prototype = {\n        checkOffset: function (offset) {\n            this.checkIndex(this.index + offset);\n        },\n        checkIndex: function (newIndex) {\n            if (this.length < this.zero + newIndex || newIndex < 0) {\n                throw new Error('End of data reached (data length = ' + this.length + ', asked index = ' + newIndex + '). Corrupted zip ?');\n            }\n        },\n        setIndex: function (newIndex) {\n            this.checkIndex(newIndex);\n            this.index = newIndex;\n        },\n        skip: function (n) {\n            this.setIndex(this.index + n);\n        },\n        byteAt: function () {\n        },\n        readInt: function (size) {\n            var result = 0, i;\n            this.checkOffset(size);\n            for (i = this.index + size - 1; i >= this.index; i--) {\n                result = (result << 8) + this.byteAt(i);\n            }\n            this.index += size;\n            return result;\n        },\n        readString: function (size) {\n            return utils.transformTo('string', this.readData(size));\n        },\n        readData: function () {\n        },\n        lastIndexOfSignature: function () {\n        },\n        readAndCheckSignature: function () {\n        },\n        readDate: function () {\n            var dostime = this.readInt(4);\n            return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));\n        }\n    };\n    return DataReader;\n});\ndefine('skylark-jszip/reader/ArrayReader',[\n    './DataReader',\n    '../utils'\n], function (DataReader, utils) {\n    'use strict';\n\n    function ArrayReader(data) {\n        DataReader.call(this, data);\n        for (var i = 0; i < this.data.length; i++) {\n            data[i] = data[i] & 255;\n        }\n    }\n    utils.inherits(ArrayReader, DataReader);\n    ArrayReader.prototype.byteAt = function (i) {\n        return this.data[this.zero + i];\n    };\n    ArrayReader.prototype.lastIndexOfSignature = function (sig) {\n        var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);\n        for (var i = this.length - 4; i >= 0; --i) {\n            if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n                return i - this.zero;\n            }\n        }\n        return -1;\n    };\n    ArrayReader.prototype.readAndCheckSignature = function (sig) {\n        var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);\n        return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n    };\n    ArrayReader.prototype.readData = function (size) {\n        this.checkOffset(size);\n        if (size === 0) {\n            return [];\n        }\n        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n        this.index += size;\n        return result;\n    };\n\n\n    return ArrayReader;\n\n});\ndefine('skylark-jszip/reader/StringReader',[\n    './DataReader',\n    '../utils'\n], function (DataReader, utils) {\n    'use strict';\n\n    function StringReader(data) {\n        DataReader.call(this, data);\n    }\n    utils.inherits(StringReader, DataReader);\n    StringReader.prototype.byteAt = function (i) {\n        return this.data.charCodeAt(this.zero + i);\n    };\n    StringReader.prototype.lastIndexOfSignature = function (sig) {\n        return this.data.lastIndexOf(sig) - this.zero;\n    };\n    StringReader.prototype.readAndCheckSignature = function (sig) {\n        var data = this.readData(4);\n        return sig === data;\n    };\n    StringReader.prototype.readData = function (size) {\n        this.checkOffset(size);\n        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n        this.index += size;\n        return result;\n    };\n    \n    return StringReader;\n});\ndefine('skylark-jszip/reader/Uint8ArrayReader',[\n    './ArrayReader',\n    '../utils'\n], function (ArrayReader, utils) {\n    'use strict';\n\n    function Uint8ArrayReader(data) {\n        ArrayReader.call(this, data);\n    }\n    utils.inherits(Uint8ArrayReader, ArrayReader);\n    Uint8ArrayReader.prototype.readData = function (size) {\n        this.checkOffset(size);\n        if (size === 0) {\n            return new Uint8Array(0);\n        }\n        var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n        this.index += size;\n        return result;\n    };\n    return Uint8ArrayReader;\n\n});\ndefine('skylark-jszip/reader/NodeBufferReader',[\n    './Uint8ArrayReader',\n    '../utils'\n], function (Uint8ArrayReader, utils) {\n    'use strict';\n\n    function NodeBufferReader(data) {\n        Uint8ArrayReader.call(this, data);\n    }\n    utils.inherits(NodeBufferReader, Uint8ArrayReader);\n    NodeBufferReader.prototype.readData = function (size) {\n        this.checkOffset(size);\n        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n        this.index += size;\n        return result;\n    };\n    return NodeBufferReader;\n});\ndefine('skylark-jszip/reader/readerFor',[\n    '../utils',\n    '../support',\n    './ArrayReader',\n    './StringReader',\n    './NodeBufferReader',\n    './Uint8ArrayReader'\n], function (utils, support, ArrayReader, StringReader, NodeBufferReader, Uint8ArrayReader) {\n    'use strict';\n\n    function readerFor(data) {\n        var type = utils.getTypeOf(data);\n        utils.checkSupport(type);\n        if (type === 'string' && !support.uint8array) {\n            return new StringReader(data);\n        }\n        if (type === 'nodebuffer') {\n            return new NodeBufferReader(data);\n        }\n        if (support.uint8array) {\n            return new Uint8ArrayReader(utils.transformTo('uint8array', data));\n        }\n        return new ArrayReader(utils.transformTo('array', data));\n    }\n\n    return readerFor;\n});\ndefine('skylark-jszip/zipEntry',[\n    './reader/readerFor',\n    './utils',\n    './compressedObject',\n    './crc32',\n    './utf8',\n    './compressions',\n    './support'\n], function (readerFor, utils, CompressedObject, crc32fn, utf8, compressions, support) {\n    'use strict';\n\n    var MADE_BY_DOS = 0;\n    var MADE_BY_UNIX = 3;\n    var findCompression = function (compressionMethod) {\n        for (var method in compressions) {\n            if (!Object.prototype.hasOwnProperty.call(compressions, method)) {\n                continue;\n            }\n            if (compressions[method].magic === compressionMethod) {\n                return compressions[method];\n            }\n        }\n        return null;\n    };\n    function ZipEntry(options, loadOptions) {\n        this.options = options;\n        this.loadOptions = loadOptions;\n    }\n    ZipEntry.prototype = {\n        isEncrypted: function () {\n            return (this.bitFlag & 1) === 1;\n        },\n        useUTF8: function () {\n            return (this.bitFlag & 2048) === 2048;\n        },\n        readLocalPart: function (reader) {\n            var compression, localExtraFieldsLength;\n            reader.skip(22);\n            this.fileNameLength = reader.readInt(2);\n            localExtraFieldsLength = reader.readInt(2);\n            this.fileName = reader.readData(this.fileNameLength);\n            reader.skip(localExtraFieldsLength);\n            if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n                throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + '(compressedSize === -1 || uncompressedSize === -1)');\n            }\n            compression = findCompression(this.compressionMethod);\n            if (compression === null) {\n                throw new Error('Corrupted zip : compression ' + utils.pretty(this.compressionMethod) + ' unknown (inner file : ' + utils.transformTo('string', this.fileName) + ')');\n            }\n            this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n        },\n        readCentralPart: function (reader) {\n            this.versionMadeBy = reader.readInt(2);\n            reader.skip(2);\n            this.bitFlag = reader.readInt(2);\n            this.compressionMethod = reader.readString(2);\n            this.date = reader.readDate();\n            this.crc32 = reader.readInt(4);\n            this.compressedSize = reader.readInt(4);\n            this.uncompressedSize = reader.readInt(4);\n            var fileNameLength = reader.readInt(2);\n            this.extraFieldsLength = reader.readInt(2);\n            this.fileCommentLength = reader.readInt(2);\n            this.diskNumberStart = reader.readInt(2);\n            this.internalFileAttributes = reader.readInt(2);\n            this.externalFileAttributes = reader.readInt(4);\n            this.localHeaderOffset = reader.readInt(4);\n            if (this.isEncrypted()) {\n                throw new Error('Encrypted zip are not supported');\n            }\n            reader.skip(fileNameLength);\n            this.readExtraFields(reader);\n            this.parseZIP64ExtraField(reader);\n            this.fileComment = reader.readData(this.fileCommentLength);\n        },\n        processAttributes: function () {\n            this.unixPermissions = null;\n            this.dosPermissions = null;\n            var madeBy = this.versionMadeBy >> 8;\n            this.dir = this.externalFileAttributes & 16 ? true : false;\n            if (madeBy === MADE_BY_DOS) {\n                this.dosPermissions = this.externalFileAttributes & 63;\n            }\n            if (madeBy === MADE_BY_UNIX) {\n                this.unixPermissions = this.externalFileAttributes >> 16 & 65535;\n            }\n            if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n                this.dir = true;\n            }\n        },\n        parseZIP64ExtraField: function () {\n            if (!this.extraFields[1]) {\n                return;\n            }\n            var extraReader = readerFor(this.extraFields[1].value);\n            if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n                this.uncompressedSize = extraReader.readInt(8);\n            }\n            if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n                this.compressedSize = extraReader.readInt(8);\n            }\n            if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n                this.localHeaderOffset = extraReader.readInt(8);\n            }\n            if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n                this.diskNumberStart = extraReader.readInt(4);\n            }\n        },\n        readExtraFields: function (reader) {\n            var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;\n            if (!this.extraFields) {\n                this.extraFields = {};\n            }\n            while (reader.index + 4 < end) {\n                extraFieldId = reader.readInt(2);\n                extraFieldLength = reader.readInt(2);\n                extraFieldValue = reader.readData(extraFieldLength);\n                this.extraFields[extraFieldId] = {\n                    id: extraFieldId,\n                    length: extraFieldLength,\n                    value: extraFieldValue\n                };\n            }\n            reader.setIndex(end);\n        },\n        handleUTF8: function () {\n            var decodeParamType = support.uint8array ? 'uint8array' : 'array';\n            if (this.useUTF8()) {\n                this.fileNameStr = utf8.utf8decode(this.fileName);\n                this.fileCommentStr = utf8.utf8decode(this.fileComment);\n            } else {\n                var upath = this.findExtraFieldUnicodePath();\n                if (upath !== null) {\n                    this.fileNameStr = upath;\n                } else {\n                    var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);\n                    this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n                }\n                var ucomment = this.findExtraFieldUnicodeComment();\n                if (ucomment !== null) {\n                    this.fileCommentStr = ucomment;\n                } else {\n                    var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);\n                    this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n                }\n            }\n        },\n        findExtraFieldUnicodePath: function () {\n            var upathField = this.extraFields[28789];\n            if (upathField) {\n                var extraReader = readerFor(upathField.value);\n                if (extraReader.readInt(1) !== 1) {\n                    return null;\n                }\n                if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                    return null;\n                }\n                return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n            }\n            return null;\n        },\n        findExtraFieldUnicodeComment: function () {\n            var ucommentField = this.extraFields[25461];\n            if (ucommentField) {\n                var extraReader = readerFor(ucommentField.value);\n                if (extraReader.readInt(1) !== 1) {\n                    return null;\n                }\n                if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                    return null;\n                }\n                return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n            }\n            return null;\n        }\n    };\n\n    return ZipEntry;\n\n});\ndefine('skylark-jszip/zipEntries',[\n    './reader/readerFor',\n    './utils',\n    './signature',\n    './zipEntry',\n    './support'\n], function (readerFor, utils, sig, ZipEntry, support) {\n    'use strict';\n\n    function ZipEntries(loadOptions) {\n        this.files = [];\n        this.loadOptions = loadOptions;\n    }\n    ZipEntries.prototype = {\n        checkSignature: function (expectedSignature) {\n            if (!this.reader.readAndCheckSignature(expectedSignature)) {\n                this.reader.index -= 4;\n                var signature = this.reader.readString(4);\n                throw new Error('Corrupted zip or bug: unexpected signature ' + '(' + utils.pretty(signature) + ', expected ' + utils.pretty(expectedSignature) + ')');\n            }\n        },\n        isSignature: function (askedIndex, expectedSignature) {\n            var currentIndex = this.reader.index;\n            this.reader.setIndex(askedIndex);\n            var signature = this.reader.readString(4);\n            var result = signature === expectedSignature;\n            this.reader.setIndex(currentIndex);\n            return result;\n        },\n        readBlockEndOfCentral: function () {\n            this.diskNumber = this.reader.readInt(2);\n            this.diskWithCentralDirStart = this.reader.readInt(2);\n            this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n            this.centralDirRecords = this.reader.readInt(2);\n            this.centralDirSize = this.reader.readInt(4);\n            this.centralDirOffset = this.reader.readInt(4);\n            this.zipCommentLength = this.reader.readInt(2);\n            var zipComment = this.reader.readData(this.zipCommentLength);\n            var decodeParamType = support.uint8array ? 'uint8array' : 'array';\n            var decodeContent = utils.transformTo(decodeParamType, zipComment);\n            this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n        },\n        readBlockZip64EndOfCentral: function () {\n            this.zip64EndOfCentralSize = this.reader.readInt(8);\n            this.reader.skip(4);\n            this.diskNumber = this.reader.readInt(4);\n            this.diskWithCentralDirStart = this.reader.readInt(4);\n            this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n            this.centralDirRecords = this.reader.readInt(8);\n            this.centralDirSize = this.reader.readInt(8);\n            this.centralDirOffset = this.reader.readInt(8);\n            this.zip64ExtensibleData = {};\n            var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n            while (index < extraDataSize) {\n                extraFieldId = this.reader.readInt(2);\n                extraFieldLength = this.reader.readInt(4);\n                extraFieldValue = this.reader.readData(extraFieldLength);\n                this.zip64ExtensibleData[extraFieldId] = {\n                    id: extraFieldId,\n                    length: extraFieldLength,\n                    value: extraFieldValue\n                };\n            }\n        },\n        readBlockZip64EndOfCentralLocator: function () {\n            this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n            this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n            this.disksCount = this.reader.readInt(4);\n            if (this.disksCount > 1) {\n                throw new Error('Multi-volumes zip are not supported');\n            }\n        },\n        readLocalFiles: function () {\n            var i, file;\n            for (i = 0; i < this.files.length; i++) {\n                file = this.files[i];\n                this.reader.setIndex(file.localHeaderOffset);\n                this.checkSignature(sig.LOCAL_FILE_HEADER);\n                file.readLocalPart(this.reader);\n                file.handleUTF8();\n                file.processAttributes();\n            }\n        },\n        readCentralDir: function () {\n            var file;\n            this.reader.setIndex(this.centralDirOffset);\n            while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n                file = new ZipEntry({ zip64: this.zip64 }, this.loadOptions);\n                file.readCentralPart(this.reader);\n                this.files.push(file);\n            }\n            if (this.centralDirRecords !== this.files.length) {\n                if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                    throw new Error('Corrupted zip or bug: expected ' + this.centralDirRecords + ' records in central dir, got ' + this.files.length);\n                } else {\n                }\n            }\n        },\n        readEndOfCentral: function () {\n            var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n            if (offset < 0) {\n                var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n                if (isGarbage) {\n                    throw new Error(\"Can't find end of central directory : is this a zip file ? \" + 'If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html');\n                } else {\n                    throw new Error(\"Corrupted zip: can't find end of central directory\");\n                }\n            }\n            this.reader.setIndex(offset);\n            var endOfCentralDirOffset = offset;\n            this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n            this.readBlockEndOfCentral();\n            if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n                this.zip64 = true;\n                offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n                if (offset < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n                }\n                this.reader.setIndex(offset);\n                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n                this.readBlockZip64EndOfCentralLocator();\n                if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                    this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                    if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                        throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                    }\n                }\n                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                this.readBlockZip64EndOfCentral();\n            }\n            var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n            if (this.zip64) {\n                expectedEndOfCentralDirOffset += 20;\n                expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;\n            }\n            var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n            if (extraBytes > 0) {\n                if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                } else {\n                    this.reader.zero = extraBytes;\n                }\n            } else if (extraBytes < 0) {\n                throw new Error('Corrupted zip: missing ' + Math.abs(extraBytes) + ' bytes.');\n            }\n        },\n        prepareReader: function (data) {\n            this.reader = readerFor(data);\n        },\n        load: function (data) {\n            this.prepareReader(data);\n            this.readEndOfCentral();\n            this.readCentralDir();\n            this.readLocalFiles();\n        }\n    };\n    return ZipEntries;\n\n});\ndefine('skylark-jszip/load',[\n    './utils',\n    './external',\n    './utf8',\n    './zipEntries',\n    './stream/Crc32Probe'\n], function (utils, external, utf8, ZipEntries, Crc32Probe) {\n    'use strict';\n\n    function checkEntryCRC32(zipEntry) {\n        return new external.Promise(function (resolve, reject) {\n            var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n            worker.on('error', function (e) {\n                reject(e);\n            }).on('end', function () {\n                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                    reject(new Error('Corrupted zip : CRC32 mismatch'));\n                } else {\n                    resolve();\n                }\n            }).resume();\n        });\n    }\n    function load(data, options) {\n        var zip = this;\n        options = utils.extend(options || {}, {\n            base64: false,\n            checkCRC32: false,\n            optimizedBinaryString: false,\n            createFolders: false,\n            decodeFileName: utf8.utf8decode\n        });\n        ///if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        ///    return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n        ///}\n        return utils.prepareContent('the loaded zip file', data, true, options.optimizedBinaryString, options.base64).then(function (data) {\n            var zipEntries = new ZipEntries(options);\n            zipEntries.load(data);\n            return zipEntries;\n        }).then(function checkCRC32(zipEntries) {\n            var promises = [external.Promise.resolve(zipEntries)];\n            var files = zipEntries.files;\n            if (options.checkCRC32) {\n                for (var i = 0; i < files.length; i++) {\n                    promises.push(checkEntryCRC32(files[i]));\n                }\n            }\n            return external.Promise.all(promises);\n        }).then(function addFiles(results) {\n            var zipEntries = results.shift();\n            var files = zipEntries.files;\n            for (var i = 0; i < files.length; i++) {\n                var input = files[i];\n                var unsafeName = input.fileNameStr;\n                var safeName = utils.resolve(input.fileNameStr);\n                zip.file(safeName, input.decompressed, {\n                    binary: true,\n                    optimizedBinaryString: true,\n                    date: input.date,\n                    dir: input.dir,\n                    comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n                    unixPermissions: input.unixPermissions,\n                    dosPermissions: input.dosPermissions,\n                    createFolders: options.createFolders\n                });\n                if (!input.dir) {\n                    zip.file(safeName).unsafeOriginalName = unsafeName;\n                }\n            }\n            if (zipEntries.zipComment.length) {\n                zip.comment = zipEntries.zipComment;\n            }\n            return zip;\n        });\n    };\n\n    return load;\n});\ndefine('skylark-jszip/JSZip',[\n    './object',\n    './load',\n    './support',\n    './defaults',\n    './external'\n], function (object, load, support, defaults, external) {\n    'use strict';\n\n    function JSZip() {\n        if (!(this instanceof JSZip)) {\n            return new JSZip();\n        }\n        if (arguments.length) {\n            throw new Error('The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.');\n        }\n        this.files = Object.create(null);\n        this.comment = null;\n        this.root = '';\n        this.clone = function () {\n            var newObj = new JSZip();\n            for (var i in this) {\n                if (typeof this[i] !== 'function') {\n                    newObj[i] = this[i];\n                }\n            }\n            return newObj;\n        };\n    }\n    JSZip.prototype = object;\n    JSZip.prototype.loadAsync = load;\n    JSZip.support = support;\n    JSZip.defaults = defaults;\n    JSZip.version = '3.10.1';\n    JSZip.loadAsync = function (content, options) {\n        return new JSZip().loadAsync(content, options);\n    };\n    JSZip.external = external;\n    return JSZip;\n\n});\ndefine('skylark-jszip/main',[\r\n    \"skylark-langx-ns\",\r\n    \"./JSZip\"\r\n], function(skylark, JSZip) {\r\n\r\n    var zip = function(data, options) {\r\n        var zip =  new JSZip();\r\n        if (arguments.length>0) {\r\n        \treturn zip.loadAsync(data, options);\r\n        } else {\r\n        \treturn zip;\r\n        }\r\n    };\r\n\r\n    zip.ZipFile = JSZip\r\n\r\n    return skylark.attach(\"intg.jszip\", zip);\r\n\r\n});\ndefine('skylark-jszip', ['skylark-jszip/main'], function (main) { return main; });\n\n"]}