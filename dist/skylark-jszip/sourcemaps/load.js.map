{"version":3,"sources":["load.js"],"names":["define","utils","external","utf8","ZipEntries","Crc32Probe","checkEntryCRC32","zipEntry","Promise","resolve","reject","worker","decompressed","getContentWorker","pipe","on","e","streamInfo","crc32","Error","resume","data","options","zip","this","extend","base64","checkCRC32","optimizedBinaryString","createFolders","decodeFileName","utf8decode","prepareContent","then","zipEntries","load","promises","files","i","length","push","all","results","shift","input","unsafeName","fileNameStr","safeName","file","binary","date","dir","comment","fileCommentStr","unixPermissions","dosPermissions","unsafeOriginalName","zipComment"],"mappings":";;;;;;;AAAAA,QACI,UACA,aACA,SACA,eACA,uBACD,SAAUC,EAAOC,EAAUC,EAAMC,EAAYC,GAC5C,aAEA,SAASC,EAAgBC,GACrB,OAAO,IAAIL,EAASM,QAAQ,SAAUC,EAASC,GAC3C,IAAIC,EAASJ,EAASK,aAAaC,mBAAmBC,KAAK,IAAIT,GAC/DM,EAAOI,GAAG,QAAS,SAAUC,GACzBN,EAAOM,KACRD,GAAG,MAAO,WACLJ,EAAOM,WAAWC,QAAUX,EAASK,aAAaM,MAClDR,EAAO,IAAIS,MAAM,mCAEjBV,MAELW,WAwDX,OArDA,SAAcC,EAAMC,GAChB,IAAIC,EAAMC,KAWV,OAVAF,EAAUrB,EAAMwB,OAAOH,OACnBI,QAAQ,EACRC,YAAY,EACZC,uBAAuB,EACvBC,eAAe,EACfC,eAAgB3B,EAAK4B,aAKlB9B,EAAM+B,eAAe,sBAAuBX,GAAM,EAAMC,EAAQM,sBAAuBN,EAAQI,QAAQO,KAAK,SAAUZ,GACzH,IAAIa,EAAa,IAAI9B,EAAWkB,GAEhC,OADAY,EAAWC,KAAKd,GACTa,IACRD,KAAK,SAAoBC,GACxB,IAAIE,GAAYlC,EAASM,QAAQC,QAAQyB,IACrCG,EAAQH,EAAWG,MACvB,GAAIf,EAAQK,WACR,IAAK,IAAIW,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAC9BF,EAASI,KAAKlC,EAAgB+B,EAAMC,KAG5C,OAAOpC,EAASM,QAAQiC,IAAIL,KAC7BH,KAAK,SAAkBS,GAGtB,IAFA,IAAIR,EAAaQ,EAAQC,QACrBN,EAAQH,EAAWG,MACdC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CACnC,IAAIM,EAAQP,EAAMC,GACdO,EAAaD,EAAME,YACnBC,EAAW9C,EAAMQ,QAAQmC,EAAME,aACnCvB,EAAIyB,KAAKD,EAAUH,EAAMhC,cACrBqC,QAAQ,EACRrB,uBAAuB,EACvBsB,KAAMN,EAAMM,KACZC,IAAKP,EAAMO,IACXC,QAASR,EAAMS,eAAed,OAASK,EAAMS,eAAiB,KAC9DC,gBAAiBV,EAAMU,gBACvBC,eAAgBX,EAAMW,eACtB1B,cAAeP,EAAQO,gBAEtBe,EAAMO,MACP5B,EAAIyB,KAAKD,GAAUS,mBAAqBX,GAMhD,OAHIX,EAAWuB,WAAWlB,SACtBhB,EAAI6B,QAAUlB,EAAWuB,YAEtBlC","file":"../load.js","sourcesContent":["define([\n    './utils',\n    './external',\n    './utf8',\n    './zipEntries',\n    './stream/Crc32Probe'\n], function (utils, external, utf8, ZipEntries, Crc32Probe) {\n    'use strict';\n\n    function checkEntryCRC32(zipEntry) {\n        return new external.Promise(function (resolve, reject) {\n            var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n            worker.on('error', function (e) {\n                reject(e);\n            }).on('end', function () {\n                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                    reject(new Error('Corrupted zip : CRC32 mismatch'));\n                } else {\n                    resolve();\n                }\n            }).resume();\n        });\n    }\n    function load(data, options) {\n        var zip = this;\n        options = utils.extend(options || {}, {\n            base64: false,\n            checkCRC32: false,\n            optimizedBinaryString: false,\n            createFolders: false,\n            decodeFileName: utf8.utf8decode\n        });\n        ///if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        ///    return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n        ///}\n        return utils.prepareContent('the loaded zip file', data, true, options.optimizedBinaryString, options.base64).then(function (data) {\n            var zipEntries = new ZipEntries(options);\n            zipEntries.load(data);\n            return zipEntries;\n        }).then(function checkCRC32(zipEntries) {\n            var promises = [external.Promise.resolve(zipEntries)];\n            var files = zipEntries.files;\n            if (options.checkCRC32) {\n                for (var i = 0; i < files.length; i++) {\n                    promises.push(checkEntryCRC32(files[i]));\n                }\n            }\n            return external.Promise.all(promises);\n        }).then(function addFiles(results) {\n            var zipEntries = results.shift();\n            var files = zipEntries.files;\n            for (var i = 0; i < files.length; i++) {\n                var input = files[i];\n                var unsafeName = input.fileNameStr;\n                var safeName = utils.resolve(input.fileNameStr);\n                zip.file(safeName, input.decompressed, {\n                    binary: true,\n                    optimizedBinaryString: true,\n                    date: input.date,\n                    dir: input.dir,\n                    comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n                    unixPermissions: input.unixPermissions,\n                    dosPermissions: input.dosPermissions,\n                    createFolders: options.createFolders\n                });\n                if (!input.dir) {\n                    zip.file(safeName).unsafeOriginalName = unsafeName;\n                }\n            }\n            if (zipEntries.zipComment.length) {\n                zip.comment = zipEntries.zipComment;\n            }\n            return zip;\n        });\n    };\n\n    return load;\n});"]}