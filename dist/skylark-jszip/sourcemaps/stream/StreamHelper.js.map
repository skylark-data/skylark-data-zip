{"version":3,"sources":["stream/StreamHelper.js"],"names":["define","utils","ConvertWorker","GenericWorker","base64","support","external","accumulate","helper","updateCallback","Promise","resolve","reject","dataArray","chunkType","_internalType","resultType","_outputType","mimeType","_mimeType","on","data","meta","push","err","result","type","content","newBlob","transformTo","encode","transformZipOutput","i","index","res","totalLength","length","join","Array","prototype","concat","apply","Uint8Array","set","Buffer","Error","e","resume","StreamHelper","worker","outputType","internalType","this","checkSupport","_worker","pipe","lock","error","updateCb","evt","fn","self","chunk","call","delay","arguments","pause","toNodejsStream","NodejsStreamOutputAdapter","objectMode"],"mappings":";;;;;;;AAAAA,QACI,WACA,kBACA,kBACA,YACA,aACA,eACD,SAAUC,EAAOC,EAAeC,EAAeC,EAAQC,EAASC,GAC/D,aAyCA,SAASC,EAAWC,EAAQC,GACxB,OAAO,IAAIH,EAASI,QAAQ,SAAUC,EAASC,GAC3C,IAAIC,KACAC,EAAYN,EAAOO,cAAeC,EAAaR,EAAOS,YAAaC,EAAWV,EAAOW,UACzFX,EAAOY,GAAG,OAAQ,SAAUC,EAAMC,GAC9BT,EAAUU,KAAKF,GACXZ,GACAA,EAAea,KAEpBF,GAAG,QAAS,SAAUI,GACrBX,KACAD,EAAOY,KACRJ,GAAG,MAAO,WACT,IACI,IAAIK,EA/CpB,SAA4BC,EAAMC,EAAST,GACvC,OAAQQ,GACR,IAAK,OACD,OAAOzB,EAAM2B,QAAQ3B,EAAM4B,YAAY,cAAeF,GAAUT,GACpE,IAAK,SACD,OAAOd,EAAO0B,OAAOH,GACzB,QACI,OAAO1B,EAAM4B,YAAYH,EAAMC,IAwCVI,CAAmBf,EArChD,SAAgBU,EAAMb,GAClB,IAAImB,EAAGC,EAAQ,EAAGC,EAAM,KAAMC,EAAc,EAC5C,IAAKH,EAAI,EAAGA,EAAInB,EAAUuB,OAAQJ,IAC9BG,GAAetB,EAAUmB,GAAGI,OAEhC,OAAQV,GACR,IAAK,SACD,OAAOb,EAAUwB,KAAK,IAC1B,IAAK,QACD,OAAOC,MAAMC,UAAUC,OAAOC,SAAU5B,GAC5C,IAAK,aAED,IADAqB,EAAM,IAAIQ,WAAWP,GAChBH,EAAI,EAAGA,EAAInB,EAAUuB,OAAQJ,IAC9BE,EAAIS,IAAI9B,EAAUmB,GAAIC,GACtBA,GAASpB,EAAUmB,GAAGI,OAE1B,OAAOF,EACX,IAAK,aACD,OAAOU,OAAOJ,OAAO3B,GACzB,QACI,MAAM,IAAIgC,MAAM,8BAAgCnB,EAAO,MAiBHc,CAAO1B,EAAWD,GAAYK,GAC1EP,EAAQc,GACV,MAAOqB,GACLlC,EAAOkC,GAEXjC,OACDkC,WAGX,SAASC,EAAaC,EAAQC,EAAYhC,GACtC,IAAIiC,EAAeD,EACnB,OAAQA,GACR,IAAK,OACL,IAAK,cACDC,EAAe,aACf,MACJ,IAAK,SACDA,EAAe,SAGnB,IACIC,KAAKrC,cAAgBoC,EACrBC,KAAKnC,YAAciC,EACnBE,KAAKjC,UAAYD,EACjBjB,EAAMoD,aAAaF,GACnBC,KAAKE,QAAUL,EAAOM,KAAK,IAAIrD,EAAciD,IAC7CF,EAAOO,OACT,MAAOV,GACLM,KAAKE,QAAU,IAAInD,EAAc,SACjCiD,KAAKE,QAAQG,MAAMX,IAqC3B,OAlCAE,EAAaT,WACThC,WAAY,SAAUmD,GAClB,OAAOnD,EAAW6C,KAAMM,IAE5BtC,GAAI,SAAUuC,EAAKC,GACf,IAAIC,EAAOT,KAUX,MATY,SAARO,EACAP,KAAKE,QAAQlC,GAAGuC,EAAK,SAAUG,GAC3BF,EAAGG,KAAKF,EAAMC,EAAMzC,KAAMyC,EAAMxC,QAGpC8B,KAAKE,QAAQlC,GAAGuC,EAAK,WACjB1D,EAAM+D,MAAMJ,EAAIK,UAAWJ,KAG5BT,MAEXL,OAAQ,WAEJ,OADA9C,EAAM+D,MAAMZ,KAAKE,QAAQP,UAAYK,KAAKE,SACnCF,MAEXc,MAAO,WAEH,OADAd,KAAKE,QAAQY,QACNd,MAEXe,eAAgB,SAAUT,GAEtB,GADAzD,EAAMoD,aAAa,cACM,eAArBD,KAAKnC,YACL,MAAM,IAAI4B,MAAMO,KAAKnC,YAAc,oCAEvC,OAAO,IAAImD,0BAA0BhB,MAAQiB,WAAiC,eAArBjB,KAAKnC,aAAgCyC,KAI/FV","file":"../../stream/StreamHelper.js","sourcesContent":["define([\n    '../utils',\n    './ConvertWorker',\n    './GenericWorker',\n    '../base64',\n    '../support',\n    '../external'\n], function (utils, ConvertWorker, GenericWorker, base64, support, external) {\n    'use strict';\n\n    ///if (support.nodestream) {\n    ///    try {\n    ///        NodejsStreamOutputAdapter = __module__6;\n    ///    } catch (e) {\n    ///    }\n    ///}\n    function transformZipOutput(type, content, mimeType) {\n        switch (type) {\n        case 'blob':\n            return utils.newBlob(utils.transformTo('arraybuffer', content), mimeType);\n        case 'base64':\n            return base64.encode(content);\n        default:\n            return utils.transformTo(type, content);\n        }\n    }\n    function concat(type, dataArray) {\n        var i, index = 0, res = null, totalLength = 0;\n        for (i = 0; i < dataArray.length; i++) {\n            totalLength += dataArray[i].length;\n        }\n        switch (type) {\n        case 'string':\n            return dataArray.join('');\n        case 'array':\n            return Array.prototype.concat.apply([], dataArray);\n        case 'uint8array':\n            res = new Uint8Array(totalLength);\n            for (i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case 'nodebuffer':\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\" + type + \"'\");\n        }\n    }\n    function accumulate(helper, updateCallback) {\n        return new external.Promise(function (resolve, reject) {\n            var dataArray = [];\n            var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;\n            helper.on('data', function (data, meta) {\n                dataArray.push(data);\n                if (updateCallback) {\n                    updateCallback(meta);\n                }\n            }).on('error', function (err) {\n                dataArray = [];\n                reject(err);\n            }).on('end', function () {\n                try {\n                    var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n                dataArray = [];\n            }).resume();\n        });\n    }\n    function StreamHelper(worker, outputType, mimeType) {\n        var internalType = outputType;\n        switch (outputType) {\n        case 'blob':\n        case 'arraybuffer':\n            internalType = 'uint8array';\n            break;\n        case 'base64':\n            internalType = 'string';\n            break;\n        }\n        try {\n            this._internalType = internalType;\n            this._outputType = outputType;\n            this._mimeType = mimeType;\n            utils.checkSupport(internalType);\n            this._worker = worker.pipe(new ConvertWorker(internalType));\n            worker.lock();\n        } catch (e) {\n            this._worker = new GenericWorker('error');\n            this._worker.error(e);\n        }\n    }\n    StreamHelper.prototype = {\n        accumulate: function (updateCb) {\n            return accumulate(this, updateCb);\n        },\n        on: function (evt, fn) {\n            var self = this;\n            if (evt === 'data') {\n                this._worker.on(evt, function (chunk) {\n                    fn.call(self, chunk.data, chunk.meta);\n                });\n            } else {\n                this._worker.on(evt, function () {\n                    utils.delay(fn, arguments, self);\n                });\n            }\n            return this;\n        },\n        resume: function () {\n            utils.delay(this._worker.resume, [], this._worker);\n            return this;\n        },\n        pause: function () {\n            this._worker.pause();\n            return this;\n        },\n        toNodejsStream: function (updateCb) {\n            utils.checkSupport('nodestream');\n            if (this._outputType !== 'nodebuffer') {\n                throw new Error(this._outputType + ' is not supported by this method');\n            }\n            return new NodejsStreamOutputAdapter(this, { objectMode: this._outputType !== 'nodebuffer' }, updateCb);\n        }\n    };\n   \n    return StreamHelper;\n});"]}