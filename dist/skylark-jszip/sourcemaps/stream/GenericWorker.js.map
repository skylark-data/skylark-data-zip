{"version":3,"sources":["stream/GenericWorker.js"],"names":["define","GenericWorker","name","this","streamInfo","generatedError","extraStreamInfo","isPaused","isFinished","isLocked","_listeners","data","end","error","previous","prototype","push","chunk","emit","flush","cleanUp","e","on","listener","arg","i","length","call","pipe","next","registerPrevious","Error","mergeStreamInfo","self","processChunk","pause","resume","withError","withStreamInfo","key","value","Object","hasOwnProperty","lock","toString","me"],"mappings":";;;;;;;AAAAA,UAAW,WACP,aAEA,SAASC,EAAcC,GACnBC,KAAKD,KAAOA,GAAQ,UACpBC,KAAKC,cACLD,KAAKE,eAAiB,KACtBF,KAAKG,mBACLH,KAAKI,UAAW,EAChBJ,KAAKK,YAAa,EAClBL,KAAKM,UAAW,EAChBN,KAAKO,YACDC,QACAC,OACAC,UAEJV,KAAKW,SAAW,KAuIpB,OArIAb,EAAcc,WACVC,KAAM,SAAUC,GACZd,KAAKe,KAAK,OAAQD,IAEtBL,IAAK,WACD,GAAIT,KAAKK,WACL,OAAO,EAEXL,KAAKgB,QACL,IACIhB,KAAKe,KAAK,OACVf,KAAKiB,UACLjB,KAAKK,YAAa,EACpB,MAAOa,GACLlB,KAAKe,KAAK,QAASG,GAEvB,OAAO,GAEXR,MAAO,SAAUQ,GACb,OAAIlB,KAAKK,aAGLL,KAAKI,SACLJ,KAAKE,eAAiBgB,GAEtBlB,KAAKK,YAAa,EAClBL,KAAKe,KAAK,QAASG,GACflB,KAAKW,UACLX,KAAKW,SAASD,MAAMQ,GAExBlB,KAAKiB,YAEF,IAEXE,GAAI,SAAUpB,EAAMqB,GAEhB,OADApB,KAAKO,WAAWR,GAAMc,KAAKO,GACpBpB,MAEXiB,QAAS,WACLjB,KAAKC,WAAaD,KAAKE,eAAiBF,KAAKG,gBAAkB,KAC/DH,KAAKO,eAETQ,KAAM,SAAUhB,EAAMsB,GAClB,GAAIrB,KAAKO,WAAWR,GAChB,IAAK,IAAIuB,EAAI,EAAGA,EAAItB,KAAKO,WAAWR,GAAMwB,OAAQD,IAC9CtB,KAAKO,WAAWR,GAAMuB,GAAGE,KAAKxB,KAAMqB,IAIhDI,KAAM,SAAUC,GACZ,OAAOA,EAAKC,iBAAiB3B,OAEjC2B,iBAAkB,SAAUhB,GACxB,GAAIX,KAAKM,SACL,MAAM,IAAIsB,MAAM,eAAiB5B,KAAO,4BAE5CA,KAAKC,WAAaU,EAASV,WAC3BD,KAAK6B,kBACL7B,KAAKW,SAAWA,EAChB,IAAImB,EAAO9B,KAUX,OATAW,EAASQ,GAAG,OAAQ,SAAUL,GAC1BgB,EAAKC,aAAajB,KAEtBH,EAASQ,GAAG,MAAO,WACfW,EAAKrB,QAETE,EAASQ,GAAG,QAAS,SAAUD,GAC3BY,EAAKpB,MAAMQ,KAERlB,MAEXgC,MAAO,WACH,OAAIhC,KAAKI,WAAYJ,KAAKK,aAG1BL,KAAKI,UAAW,EACZJ,KAAKW,UACLX,KAAKW,SAASqB,SAEX,IAEXC,OAAQ,WACJ,IAAKjC,KAAKI,UAAYJ,KAAKK,WACvB,OAAO,EAEXL,KAAKI,UAAW,EAChB,IAAI8B,GAAY,EAQhB,OAPIlC,KAAKE,iBACLF,KAAKU,MAAMV,KAAKE,gBAChBgC,GAAY,GAEZlC,KAAKW,UACLX,KAAKW,SAASsB,UAEVC,GAEZlB,MAAO,aAEPe,aAAc,SAAUjB,GACpBd,KAAKa,KAAKC,IAEdqB,eAAgB,SAAUC,EAAKC,GAG3B,OAFArC,KAAKG,gBAAgBiC,GAAOC,EAC5BrC,KAAK6B,kBACE7B,MAEX6B,gBAAiB,WACb,IAAK,IAAIO,KAAOpC,KAAKG,gBACZmC,OAAO1B,UAAU2B,eAAef,KAAKxB,KAAKG,gBAAiBiC,KAGhEpC,KAAKC,WAAWmC,GAAOpC,KAAKG,gBAAgBiC,KAGpDI,KAAM,WACF,GAAIxC,KAAKM,SACL,MAAM,IAAIsB,MAAM,eAAiB5B,KAAO,4BAE5CA,KAAKM,UAAW,EACZN,KAAKW,UACLX,KAAKW,SAAS6B,QAGtBC,SAAU,WACN,IAAIC,EAAK,UAAY1C,KAAKD,KAC1B,OAAIC,KAAKW,SACEX,KAAKW,SAAW,OAAS+B,EAEzBA,IAKZ5C","file":"../../stream/GenericWorker.js","sourcesContent":["define([], function () {\n    'use strict';\n\n    function GenericWorker(name) {\n        this.name = name || 'default';\n        this.streamInfo = {};\n        this.generatedError = null;\n        this.extraStreamInfo = {};\n        this.isPaused = true;\n        this.isFinished = false;\n        this.isLocked = false;\n        this._listeners = {\n            'data': [],\n            'end': [],\n            'error': []\n        };\n        this.previous = null;\n    }\n    GenericWorker.prototype = {\n        push: function (chunk) {\n            this.emit('data', chunk);\n        },\n        end: function () {\n            if (this.isFinished) {\n                return false;\n            }\n            this.flush();\n            try {\n                this.emit('end');\n                this.cleanUp();\n                this.isFinished = true;\n            } catch (e) {\n                this.emit('error', e);\n            }\n            return true;\n        },\n        error: function (e) {\n            if (this.isFinished) {\n                return false;\n            }\n            if (this.isPaused) {\n                this.generatedError = e;\n            } else {\n                this.isFinished = true;\n                this.emit('error', e);\n                if (this.previous) {\n                    this.previous.error(e);\n                }\n                this.cleanUp();\n            }\n            return true;\n        },\n        on: function (name, listener) {\n            this._listeners[name].push(listener);\n            return this;\n        },\n        cleanUp: function () {\n            this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n            this._listeners = [];\n        },\n        emit: function (name, arg) {\n            if (this._listeners[name]) {\n                for (var i = 0; i < this._listeners[name].length; i++) {\n                    this._listeners[name][i].call(this, arg);\n                }\n            }\n        },\n        pipe: function (next) {\n            return next.registerPrevious(this);\n        },\n        registerPrevious: function (previous) {\n            if (this.isLocked) {\n                throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            }\n            this.streamInfo = previous.streamInfo;\n            this.mergeStreamInfo();\n            this.previous = previous;\n            var self = this;\n            previous.on('data', function (chunk) {\n                self.processChunk(chunk);\n            });\n            previous.on('end', function () {\n                self.end();\n            });\n            previous.on('error', function (e) {\n                self.error(e);\n            });\n            return this;\n        },\n        pause: function () {\n            if (this.isPaused || this.isFinished) {\n                return false;\n            }\n            this.isPaused = true;\n            if (this.previous) {\n                this.previous.pause();\n            }\n            return true;\n        },\n        resume: function () {\n            if (!this.isPaused || this.isFinished) {\n                return false;\n            }\n            this.isPaused = false;\n            var withError = false;\n            if (this.generatedError) {\n                this.error(this.generatedError);\n                withError = true;\n            }\n            if (this.previous) {\n                this.previous.resume();\n            }\n            return !withError;\n        },\n        flush: function () {\n        },\n        processChunk: function (chunk) {\n            this.push(chunk);\n        },\n        withStreamInfo: function (key, value) {\n            this.extraStreamInfo[key] = value;\n            this.mergeStreamInfo();\n            return this;\n        },\n        mergeStreamInfo: function () {\n            for (var key in this.extraStreamInfo) {\n                if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {\n                    continue;\n                }\n                this.streamInfo[key] = this.extraStreamInfo[key];\n            }\n        },\n        lock: function () {\n            if (this.isLocked) {\n                throw new Error(\"The stream '\" + this + \"' has already been used.\");\n            }\n            this.isLocked = true;\n            if (this.previous) {\n                this.previous.lock();\n            }\n        },\n        toString: function () {\n            var me = 'Worker ' + this.name;\n            if (this.previous) {\n                return this.previous + ' -> ' + me;\n            } else {\n                return me;\n            }\n        }\n    };\n\n    return GenericWorker;\n\n});"]}