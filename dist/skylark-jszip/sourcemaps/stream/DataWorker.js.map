{"version":3,"sources":["stream/DataWorker.js"],"names":["define","utils","GenericWorker","DataWorker","dataP","call","this","self","dataIsReady","index","max","data","type","_tickScheduled","then","length","getTypeOf","isPaused","_tickAndRepeat","e","error","inherits","prototype","cleanUp","resume","delay","isFinished","_tick","nextIndex","Math","min","end","substring","subarray","slice","push","meta","percent"],"mappings":";;;;;;;AAAAA,QACI,WACA,mBACD,SAAUC,EAAOC,GAChB,aAGA,SAASC,EAAWC,GAChBF,EAAcG,KAAKC,KAAM,cACzB,IAAIC,EAAOD,KACXA,KAAKE,aAAc,EACnBF,KAAKG,MAAQ,EACbH,KAAKI,IAAM,EACXJ,KAAKK,KAAO,KACZL,KAAKM,KAAO,GACZN,KAAKO,gBAAiB,EACtBT,EAAMU,KAAK,SAAUH,GACjBJ,EAAKC,aAAc,EACnBD,EAAKI,KAAOA,EACZJ,EAAKG,IAAMC,GAAQA,EAAKI,QAAU,EAClCR,EAAKK,KAAOX,EAAMe,UAAUL,GACvBJ,EAAKU,UACNV,EAAKW,kBAEV,SAAUC,GACTZ,EAAKa,MAAMD,KA0DnB,OAvDAlB,EAAMoB,SAASlB,EAAYD,GAC3BC,EAAWmB,UAAUC,QAAU,WAC3BrB,EAAcoB,UAAUC,QAAQlB,KAAKC,MACrCA,KAAKK,KAAO,MAEhBR,EAAWmB,UAAUE,OAAS,WAC1B,QAAKtB,EAAcoB,UAAUE,OAAOnB,KAAKC,SAGpCA,KAAKO,gBAAkBP,KAAKE,cAC7BF,KAAKO,gBAAiB,EACtBZ,EAAMwB,MAAMnB,KAAKY,kBAAoBZ,QAElC,IAEXH,EAAWmB,UAAUJ,eAAiB,WAClCZ,KAAKO,gBAAiB,EAClBP,KAAKW,UAAYX,KAAKoB,aAG1BpB,KAAKqB,QACArB,KAAKoB,aACNzB,EAAMwB,MAAMnB,KAAKY,kBAAoBZ,MACrCA,KAAKO,gBAAiB,KAG9BV,EAAWmB,UAAUK,MAAQ,WACzB,GAAIrB,KAAKW,UAAYX,KAAKoB,WACtB,OAAO,EAEX,IACIf,EAAO,KAAMiB,EAAYC,KAAKC,IAAIxB,KAAKI,IAAKJ,KAAKG,MArDhC,OAsDrB,GAAIH,KAAKG,OAASH,KAAKI,IACnB,OAAOJ,KAAKyB,MAEZ,OAAQzB,KAAKM,MACb,IAAK,SACDD,EAAOL,KAAKK,KAAKqB,UAAU1B,KAAKG,MAAOmB,GACvC,MACJ,IAAK,aACDjB,EAAOL,KAAKK,KAAKsB,SAAS3B,KAAKG,MAAOmB,GACtC,MACJ,IAAK,QACL,IAAK,aACDjB,EAAOL,KAAKK,KAAKuB,MAAM5B,KAAKG,MAAOmB,GAIvC,OADAtB,KAAKG,MAAQmB,EACNtB,KAAK6B,MACRxB,KAAMA,EACNyB,MAAQC,QAAS/B,KAAKI,IAAMJ,KAAKG,MAAQH,KAAKI,IAAM,IAAM,MAK/DP","file":"../../stream/DataWorker.js","sourcesContent":["define([\n    '../utils',\n    './GenericWorker'\n], function (utils, GenericWorker) {\n    'use strict';\n\n    var DEFAULT_BLOCK_SIZE = 16 * 1024;\n    function DataWorker(dataP) {\n        GenericWorker.call(this, 'DataWorker');\n        var self = this;\n        this.dataIsReady = false;\n        this.index = 0;\n        this.max = 0;\n        this.data = null;\n        this.type = '';\n        this._tickScheduled = false;\n        dataP.then(function (data) {\n            self.dataIsReady = true;\n            self.data = data;\n            self.max = data && data.length || 0;\n            self.type = utils.getTypeOf(data);\n            if (!self.isPaused) {\n                self._tickAndRepeat();\n            }\n        }, function (e) {\n            self.error(e);\n        });\n    }\n    utils.inherits(DataWorker, GenericWorker);\n    DataWorker.prototype.cleanUp = function () {\n        GenericWorker.prototype.cleanUp.call(this);\n        this.data = null;\n    };\n    DataWorker.prototype.resume = function () {\n        if (!GenericWorker.prototype.resume.call(this)) {\n            return false;\n        }\n        if (!this._tickScheduled && this.dataIsReady) {\n            this._tickScheduled = true;\n            utils.delay(this._tickAndRepeat, [], this);\n        }\n        return true;\n    };\n    DataWorker.prototype._tickAndRepeat = function () {\n        this._tickScheduled = false;\n        if (this.isPaused || this.isFinished) {\n            return;\n        }\n        this._tick();\n        if (!this.isFinished) {\n            utils.delay(this._tickAndRepeat, [], this);\n            this._tickScheduled = true;\n        }\n    };\n    DataWorker.prototype._tick = function () {\n        if (this.isPaused || this.isFinished) {\n            return false;\n        }\n        var size = DEFAULT_BLOCK_SIZE;\n        var data = null, nextIndex = Math.min(this.max, this.index + size);\n        if (this.index >= this.max) {\n            return this.end();\n        } else {\n            switch (this.type) {\n            case 'string':\n                data = this.data.substring(this.index, nextIndex);\n                break;\n            case 'uint8array':\n                data = this.data.subarray(this.index, nextIndex);\n                break;\n            case 'array':\n            case 'nodebuffer':\n                data = this.data.slice(this.index, nextIndex);\n                break;\n            }\n            this.index = nextIndex;\n            return this.push({\n                data: data,\n                meta: { percent: this.max ? this.index / this.max * 100 : 0 }\n            });\n        }\n    };\n    \n    return DataWorker;\n});"]}